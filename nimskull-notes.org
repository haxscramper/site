#+title: Why nimskull
#+options: broken-links:mark

# TODO https://matrix.to/#/!alsWvZtOfWkQlHwcHC:envs.net/$InF0jWs3VKmmsZTRa_lzWKMyNQXsdcdJanLunNsTlqc?via=libera.chat&via=matrix.org&via=matrix.shaggypeak.com add discussion insights from the discussion

# TODO  how  often each  line  in  testament/important packages  have  been
# edited.  How long  has  drnim been  staying in  the  compiler code  base.
# Interesting attitude for the "code rot" implementation.

After another round  of discussions about possible  objectives, reasons and
merits of the Nim fork I've been working  on I decided to write down my own
thoughts on this matter, elaborate  on the decision-making process that has
led to the specific wording of the readme.

---------------------------------------------------------------------------

Disclaimer: this  article is going  to have a  lot of disclaimers  down the
road, but  ultimately I admit  the attempt to  write it in  the "objective"
manner failed,  since I have too  much personal investment in  the issue. I
tried to keep the tone in check, but you can never be completely sure.

---------------------------------------------------------------------------

Some parts of this article are going to be outdated in the future -- mostly
stuff  concerning PR  aspect of  the  project, how  we advertise  different
elements of it and so on. If  there are going to be any fundamental changes
I will update this text accordingly.

---------------------------------------------------------------------------

To save you  some time, my top  picks when it comes to  spreading FUD about
nimskull are the following, in order of my preference:

1. /"Well good luck hard-forking backwards into the past to re-write commit
   messages."/ ([[https://news.ycombinator.com/item?id=32033473][link]]  and I'm /still/  really puzzled  as to what  the hell
   does that  mean, so if you  want to FUD  in comments *and* use  this one
   *and* can explain it -- I will be really glad to see you)
2. /"Forks  that seem to  exist for no  clear reason other  than disgruntled
   person(s) thumbing their nose at an upstream maintainer never do."/
3. /"So, nimskull is a project management exercise, carry on then"/

* WIP Part one: "why"

Important  disclaimer before  I  go  into long  and  annoying  list of  all
failings that  happened over the  years --  I *personally* think  that this
sort of conduct  is bad and poorly reflects on  the community health. There
might be other points of view, either on specific issues or in general.

Some might consider  a missing Code of Conduct a  major problem, some might
be hell-bent  on a [[https://forum.nim-lang.org/t/9511#62471][multiple]] instances  of a very unwelcome  language, weird
[[https://forum.nim-lang.org/t/9402#61840][rhetoric]] and so on, but I included things that I, *personally*, consider to
be important.

---------------------------------------------------------------------------


Most common questions concerning "why" aspect  of the project I've seen can
be summarized in the following phrase: "why fork if you can just contribute
to the mainline" or  "why not contribute to the mainline".  There are a few
things in this sentence that need to be unpacked, specifically in the first
variant of it. It  is not always used in this literal form,  but I saw that
formulation often enough to go into the sentence dissection mode.

Let's get  the most  obvious and  irritating response out  of the  way. The
response to *"why do X"* is pretty simple: "because I'm a free person to do
what I want with my free time". So I decided to work on the fork instead of
a main project.

Of course this is just a blanket  "buzz off" response that does not address
the important  questions, but I decided  it is important enough  to warrant
the inclusion.

Second and a lot more controversial response targets the *"just"* word. I'm
sure there are  realms of irritated blog posts, articles  and books written
about "why don't you just do X" and how often it is not all that easy.

Before I go into long detailed list of what is wrong with the mainline, I'm
going  to say  that we  (nimskull contributor  team) explicitly  decided to
*not* to include these sort of historical elaboration in the readme because
it does not  generally help the discussion. Instead of  looking forward and
deciding what do next the discourse  is focused on seeking someone to blame
for various issues.

I've contemplated the idea of writing this  kind of article for a long time
and after about  a year of hearing various questions,  ranging from genuine
confusion (e.g. newcomer  to the mainline gets disoriented  about status of
each projects and  seeks some elaboration) to a commonplace  HN FUD that is
based on the quick skim of the readme.


https://discord.com/channels/371759389889003530/371759607934353448/915902483086323732

https://discord.com/channels/371759389889003530/371759607934353448/915895070803243008

https://discord.com/channels/371759389889003530/371759389889003532/910564109764935781

https://discord.com/channels/371759389889003530/371759389889003532/910579516903157781

https://github.com/nim-lang/nimble/pull/913#issuecomment-873565439

https://discord.com/channels/371759389889003530/371759607934353448/915916352450088961

> the delete circus with nimStrictDelete is something I will probably never understand

** Issues with package management

On July 4th, 2021 I wrote  the [[https://github.com/nim-lang/RFCs/issues/398][RFC]] detailing various issues and suggestions
for the package management improvements that provided a detailed account of
most of the things that were wrong with the package manager at the time.

*** UX and implementation issues

*** Non-existent level of interest in package manager improvements

1. Non-existent dependency  resolution algorithm that can  get knocked over
   at any time, causing bugs and repeated installations.
2. Bidirectional data  flow between the compiler and package  manager -- it
   is not  possible to  run the  compiler separately with  the same  set of
   packages as in command-line.

*** Dead community management

#+begin_quote
By  the  way,   speaking  of  roadmap  and  project   [[https://irclogs.nim-lang.org/03-11-2021.html#11:44:14][management]]  -  nimble
"development has been  outsourced, wasn't ready for 1.6.0 and  I don't know
the plan either"[fn:either-96] -- this happened moths after long discussion
about  added nimble  features, subsequent  reversal  of the  version to  be
release https://forum.nim-lang.org/t/8404#54511 and we still don't have any
concrete roadmap about plans to roll out 14.0.

So these are my two cents on how having a good roadmap could've prevented a
almost  a year's  worth  of  effort (pattern  matching)  to  not lose  it's
maintainer, and how you managed to loose a single person who was interested
enough to really  try to compose the plans,  suggestions, improvement ideas
and  vision for  the  package  manager into  something  coherent, not  "the
discussions were  spread through  multiple Github  issues, IRC  and private
chats with the Nim team on Telegram" [[https://discord.com/channels/371759389889003530/753721959308853319/892742985626824734][discord link]].

This is my personal view of the matter, I'm not going to lie and say that I don't care anymore, but I'm certainly burned out by this indifference and uncertainty to the point I no longer want to do anything unless explicitly asked for - and this certainly would not include "please continue to maintain pattern matching"

P.S. you can consider it my resignation letter from the fusion/matching maintainer. I wanted it come to become a standard, but well, not like I can continue to work on it if the fusion itself is dead.
#+end_quote

[fn:either-96] Remember -- this is a main project contributor talking about
their

** TODO Issues with the implementation

This section outlines what is wrong  with the current implementation -- for
our solutions to fixing the problems see the "our vision" section below.

*** Technical introduction

Before  discussing issues  with the  implementation it  would be  more than
appropriate  to  provide  brief  overview  of  the  implementation  because
understanding some of the issues  requires either hands-on experience or at
least basic familiarity with the problem domain.

**** High-level compiler architecture

Mostly aimed  at people  unfamiliar with how  compilers are  implemented in
general  and how  nim is  implemented specifically.  Relevant parts  of the
source code are linked  from the text (TODO). The links  are absolute (to a
specific version of the file) to avoid potential bitrot in the text.

Nim compiler  has a  classic compilation  architecture, split  into several
high-level  stages:  tokenization,  parsing,  semantic  analysis  and  code
generation.

- Tokenization  ::  Splits input  source file into  series of  smaller text
  units which are called tokens. Each  token has it's own *kind* and value.
  There  are  many   different  kinds  of  tokens,   such  as  "identifier"
  (variables, argument names, type  names), "keyword" (~for~, ~while~, ~if~
  and so on), "literal" (~1~, ~"test"~ in code)
- Parsing :: Sequence of input tokens  is turned into a tree structure TODO
  expand more?
- Semantic analysis :: parsed tree  structure is processed further and more
  information  is added  to it  (identifiers  are turned  into symbols  and
  assigned types,  expressions are simplified) and  metaprogramming actions
  are executed.

  This part of the compilation pipeline has several important steps

  - Macro expansion  :: Macro  and template  calls are  repeatedly expanded
    into a new AST. TODO

    Macro execution is performed using embedded virtual machine
  - Constant folding :: Constant expressions  in code that can be evaluated
    are turned into simple literals. TODO example
  - Lifting lambdas :: TODO
  - Destructor injection :: TODO
- Code generation :: After all parts  of the semantic analysis are complete
  resulting AST is turned into backend code.

Several  important things  can happen  during any  part of  the compilation
pipeline:

- Diagnostics reporting :: Any part of the compilation pipeline can issue a
  diagnostic message (hint, warning or  error) that might potentially abort
  the whole compilation process.
- File import  and include ::   External module import process is performed
  during semantic analysis and can  effectively switch the current "active"
  part of the compilation process.

*** Handling of the community requests

Nim-lang conducts a  yearly community survey with results  available on the
blog. [[https://nim-lang.org/blog/2022/01/14/community-survey-results-2021.html][2021]], [[https://nim-lang.org/blog/2021/01/20/community-survey-results-2020.html][2020]], [[https://nim-lang.org/blog/2020/02/18/community-survey-results-2019.html][2019]], [[https://nim-lang.org/blog/2018/10/27/community-survey-results-2018.html][2018]], [[https://nim-lang.org/blog/2017/10/01/community-survey-results-2017.html][2017]], [[https://nim-lang.org/blog/2016/09/03/community-survey-results-2016.html][2016]]. Some questions persisted over the
years.

#+caption: "Top/High", "Medium" and "Low/Ok" priority
| Question             | 2021     | 2020     | 2019     | 2018 | 2017 | 2016 |
| Fixing compiler bugs | 68/20/12 | 55/28/17 | 55/26/20 | N/A  | N/A  | N/A  |
| Improving tooling    | 49/29/22 | 43/30/26 | N/A      | N/A  | N/A  | N/A  |
| Documentation        | 40/36/24 | 42/30/28 | 50/26/24 | N/A  | N/A  | N/A  |

As you  can see,  over last  two years number  of respondents  who consider
current  implementation  acceptable  in  terms  of  bugs  decreased  almost
twofold, from  20% to 12%,  while the number  of those who  consider fixing
compiler bugs to be of high  or critical importance increased by 13%. Prior
to 2018 this question was not being asked.

Priority of  the tooling  improvement had  been asked  only twice,  but the
declining trend is present here, although not as drastically.

Documentation quality is steadily improving year-over-year.

*** TODO Compiler documentation

**** TODO Lack of the literal documentation

Large  parts of  the  compiler  codebase are  not  properly documented  and
explained.

**** TODO No high-level overview of the compiler internals

**** TODO The code is still effectively owned by a single person

*** Error messages

I've written several RFCs regarding  error message formatting and handling:
[[https://github.com/nim-lang/RFCs/issues/323][Compiler error suggestions · Issue #323]], [[https://github.com/nim-lang/RFCs/issues/324][Structured compilation errors ·
Issue #324]],  [[https://github.com/nim-lang/RFCs/issues/325][Type mismatch errors ·  Issue #325]] so I  will briefly rehash
the issues  regarding user-facing side of  things and implementation-facing
side. To the error quality RFC I got a lovely response

#+begin_quote
Feel free to improve the compiler's error messages. There is not much to disagree here with. (For me the error messages are good enough but I don't use mapIt nor noSideEffect.)
#+end_quote

It took  approximately two months of  work, almost twenty thousand  line of
changes in  173 compiler files  and significant  help of the  several other
contributors to  [[https://github.com/nim-works/nimskull/pull/94][provide]] a  /basis/ for further  error improvements.  And I
that  was  preceded  by almost  a  year  of  bashing  my head  against  the
implementation of the compiler in order to make sense out of it.

- Function  call  resolution  failures  were  created  with  little  to  no
  consideration to the  formatting quality. Things are  simply formatted as
  strings, [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/semcall.nim#L264][sorted]] in an alphabetical order and printed out.
- Error  messages themselves  are implemented  using almost  every possible
  solution, including direct string [[https://github.com/nim-lang/Nim/blob/4728c52c787b19c60a5533e20b7d71ee9ca137a3/compiler/semstmts.nim#L51][formatting]] and [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/semcall.nim#L413][concatenation]] (sometimes
  with [[https://github.com/nim-lang/Nim/blob/5602183234f59ece4fd668915da848f0753cbbb9/compiler/pragmas.nim#L116][raw]] ~PNode~  renders -- remember these lovely "but  expression has a
  type" with ~mapIt~ results), [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/msgs.nim#L577][formatting]] [[https://github.com/nim-lang/Nim/blob/5602183234f59ece4fd668915da848f0753cbbb9/compiler/lineinfos.nim#L106][enums]], formatting from the [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/semcall.nim#L280][consts]]
  that are indistinguishable from the enums but for some reason were placed
  separately.
- Current "new" idea  of the ~nkError~ never went [[https://github.com/nim-lang/Nim/search?q=nkError][anywhere]]  (link to the GH
  search  --  at the  time  of  writing it  shows  only  five uses  of  the
  ~nkError~) after it had been [[https://github.com/nim-lang/Nim/commit/cfff27529e4ec129daad602d945a2b222145e922][added]].
- It is not possible to get errors  in a structured manner, one that can be
  used for testing without  hardcoding current rendering format. Separation
  of data and presentation  -- not that hard of a concept  to grasp, yet to
  this day,  if you  need to  change even  a single  character in  an error
  formatting, you also need to go and update all tests suits that have this
  error. Each time.
- There  is no  encouragement of  the incremental  error improvements,  and
  thanks to  the necessity to  edit the test suite  each time it  becomes a
  major chore.

***** Random hacks all over the place

Proliferation of hard-to-spot hacks that  are at best sparingly documented,
at  worst  require  a  lot  of  guesswork  got  figure  out.  For  example,
[[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/lexer.nim#L887][lexer.getSymbol]] [[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/lexer.nim#L923][uses]] enum ~ord()~ and ~PIdent~ id addition (or [[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/lexer.nim#L934][subtraction]])
in order to  figure out the kind  of the token. Why are  identifier ids are
guaranteed to be mapped to  tokens? Maybe because ~newIdentCache~ [[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/idents.nim#L114][fills ids]]
at the  start with values from  the [[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/wordrecg.nim#L17][~TSpecialWord~]]? But how  latter enum is
related  to the  [[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/lexer.nim#L37][~TokenKind~]]  we are  trying to  figure  out? (they  /look/
similar, but is that  intentional?) Why do we need to  [[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/lexer.nim#L896][hash]] the token value
in the ~getSymbol~? Why do hashing in the ~getOperator~? Can't we just keep
a map ~token-string -> token-kind~ conversion?

Kludges are thrown  on each other all over the  place ~Token.iNumber~ is an
integer  literal  of   a  token,  according  to   the  [[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/lexer.nim#L101][documentation]]  (BTW,
single-hash-comments are not processed  by the documentation generator, yet
compiler uses them  for docs anyway -  as you can see in  the linked file),
but it is  also a (1) place to  [[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/lexer.nim#L441][split]] user numerical literals at  and a (2)
[[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/lexer.nim#L1094][number]] of newlines in the comment token

When an  error message is written  out it goes into  ~writeLnHook~ callback
(misused for ~{.explain.}~)  (hacked for ~compiles()~) and  was written out
to the stdout/stderr.

Of course you can't  have a proper error reporting in  the nim compiler, so
this hook was also misused to  the point of complete nonsense. Most notable
clusterfuck  where you  could spot  this little  shit is  implementation of
~{.explain.}~ pragma  for concepts. It  was implemented via  really 'smart'
(aka welcome to hell) solution in

[[https://github.com/nim-works/nimskull/commit/74a80988d9289e8147a791c4b0939d4287baaff3][74a8098]] (=sigmatch= ~704) and then further "improved" in [[https://github.com/nim-lang/Nim/commit/fe48dd1cbec500298f7edeb75f1d6fef8490346c][fe48dd1]] by slicing
out  parts  of  the  error  message with  ~let  msg  =  s.replace("Error:",
errorPrefix)~

*** Quality of the source code

**** Commit messages

Source code implementation has an absolutely appauling quality with unclear
commit  messages and  a very  interesting [[https://github.com/nim-lang/Nim/pull/19211][attitude]]  from some  of the  core
developers.

#+begin_quote
I have no intention to follow this guideline so I cannot accept it. The problem is real, but the solution is to write some simple tool that makes "git log" more useful.
#+end_quote

The PR  was merged at [2021-12-03  Fri], but it didn't  really prevent [[https://github.com/nim-lang/Nim/commit/07b645342abd06b2323df042c170eb847f51880d][more]]
[[https://github.com/nim-lang/Nim/commit/48d41ab375498ba638863b55807bac96eccf667a][fixes]],  [[https://github.com/nim-lang/Nim/commit/81087c949f620dc80697364da414872791ffe23c][fixes]], [[https://github.com/nim-lang/Nim/commit/81087c949f620dc80697364da414872791ffe23c][fixes]],  [[https://github.com/nim-lang/Nim/commit/08ae3467b9b3f52fa568bbf06a9057a87020158b][refactorings]],  [[https://github.com/nim-lang/Nim/commit/6d8178a93e14f24cbb327cf718de181942339126][closes]] etc.  But I  guess  it is  not
surprising given core contributors seem  to have an inverse proportion wrt.
to the number of commits and  their documentation, starting with =Araq= not
writing anything else beside a title (49 characters).

#+caption: Average commit message lenght
#+begin_src elvish
var file = "/tmp/count"
git log --pretty="format:%an;;;%s %b" | cat | rg "(Andreas Rumpf|Araq)" | sd "^.*?;;;" "" > $file
echo "Average commit: "(echo (wc -c < $file) "/" (wc -l < $file) | bc -l)", #commits "(wc -l < $file)
#+end_src

| Core contributor | average message length | number of commits | status   |
|------------------+------------------------+-------------------+----------|
| Araq             |                  48.59 |              8898 | active   |
| Dom96            |                  64.00 |              1477 | active   |
| Timothee Cour    |                     82 |              1088 | inactive |

**** Code quality itself

Before going into specific examples I want to briefly outline the situation
with  the data  flow  inside of  compiler  and what  types  are often  used
internally.

The most important type you should know about is ~PNode~ -- the name itself
is a pascal-era artifact and effectively  means "node". The type is used to
represent your  code inside of the  compiler -- all files  are first parsed
into ~PNode~ then sem modifies it and finally generates the target code for
various backends.  The whole compiler  pipeline uses the single  type, from
start to finish.

~PNode~ [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/ast.nim#L785][is]] a variant [[https://nim-lang.org/docs/manual.html#types-object-variants][object]] that uses [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/ast.nim#L36][TNodeKind]] as a switch type. Kinds are
divided  into two  broad categories  -- literals  (integer, floating-point,
string)  and 'container'  (definitions, statements,  expressions etc)  that
store nodes in a strictly ordered fashion.

***** Magical indices all over the code

Access to  the data in  the AST is  largely performed using  direct indexed
access --  there are over  four thousand naked ~[IDX]~  accesses throughout
the code  (~rg '\[\d+\]' |  wc -l~ => 4601  ATTOW). In order  to understand
what [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/semexprs.nim#L2498][some]]  [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/semstmts.nim#L1863-L1864][piece]] of  [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/semstmts.nim#L1448-L1453][code]] might  be doing you  would need  to know  all the
possible node kinds that pass through this part of the code.

Explanation  for the  transformations that  are performed  on the  nodes is
largely absent.

***** Tens of thousands of one-character variables

Number  of  one-character  variables  in the  implementation  is  downright
obscene. There  are some common  cases like  ~g~ or ~ModuleGraph~,  ~c~ for
~PContext~,  ~TContext~  or  ~PPassContext~,  ~m~  for  ~Module~,  ~n~  for
~PNode~, but overall number of the  one-char variable usages goes into tens
of thousands (~rg -g "*.nim"  '[\s(.\[][a-z][\s)=.:\[\]]' | wc -l~ => 33834
ATTOW) sometimes concentrating in an absolutely unimaginable numbers:

#+begin_quote
one-char [[https://github.com/nim-lang/Nim/blob/f540fd5cde268d2ecd1e22a20cac0879bf405f85/compiler/passes.nim#L121-L124][variables]]  followed by two  nested loops that introduce  [[https://github.com/nim-lang/Nim/blob/f540fd5cde268d2ecd1e22a20cac0879bf405f85/compiler/passes.nim#L155][more]] than
[[https://github.com/nim-lang/Nim/blob/f540fd5cde268d2ecd1e22a20cac0879bf405f85/compiler/passes.nim#L177][shadow]] them. This  part of the compiler serves as  a main semantic analysis
entry point  if I'm  not mistaken -  I'm writing this  while I'm  trying to
decipher its purpose, so I might be a big wrong.
#+end_quote


#+begin_quote
[[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2209][sigmatch.paramTypesMatch]] has a total of *NINE* one-character variables - [[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2209][m]],
[[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2209][f]],  [[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2209][a]], [[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2220][x]],  [[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2221][y]], [[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2222][z]],  [[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2218][c]], [[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2237][r]],  [[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2227][i]], all  involved in  a complex  algorithm of  best
candidate argument  search - that's about  a third of an  english alphabet.
Good to know the algorithm complexity  has such robust limiting mechanism -
at most you can write code that is three times as complex, not more.
#+end_quote

***** Sea of 'convenience' templates

Large  number of  'convenience' templates  that  (1) do  not specify  their
argument  types, (2)  implicitly  capture something  (or  expect) from  the
environment .  Examples include both [[https://github.com/nim-lang/Nim/blob/8dcf367e5223ae26b57c9bbfaec6e70ac14bb820/compiler/lexer.nim#L258][tokenEnd]],  [[https://github.com/nim-lang/Nim/blob/8dcf367e5223ae26b57c9bbfaec6e70ac14bb820/compiler/lexer.nim#L283][eatChar]], [[https://github.com/nim-lang/Nim/blob/8dcf367e5223ae26b57c9bbfaec6e70ac14bb820/compiler/lexer.nim#L269][tokenEndPrevious]] -
which are not  so bad, and [[https://github.com/nim-lang/Nim/blob/8dcf367e5223ae26b57c9bbfaec6e70ac14bb820/compiler/vm.nim#L78][vm.stackTrace]] which  injects ~return~, obscuring
the control flow each time it is used in the code.

TODO astrepr implementation with ~compiles~ hacks

***** Exceptions for control flow

~globalError~ and ~ERecoverableError~ for control flow handling - there are
around  *one hundred*  (105  ATTOW)  calls to  the  ~globalError~ that  can
arbitrarily raise "recoverable" exception during semantic analysis which is
then   caught  in   the   ~semexpr~  and   discarded  (~tryExpr~,   ~except
ERecoverableError: discard~) and [[https://github.com/nim-lang/Nim/blob/b6bfe38ff5283f77d5e5e78da06d2710bc16afb6/compiler/sem.nim#L361][some]] [[https://github.com/nim-lang/Nim/blob/b6bfe38ff5283f77d5e5e78da06d2710bc16afb6/compiler/sem.nim#L662][more]] [[https://github.com/nim-lang/Nim/blob/d4c0d35b32e51eae06e65e78c253cdaf8bb42446/compiler/suggest.nim#L614][examples]] of [[https://github.com/nim-lang/Nim/blob/0014b9c48e883d3c04995b9e83bb0f8468a16df6/compiler/semexprs.nim#L2204][this]].

Exceptions being used  for control, discarding exceptions  - again, someone
(like me)  might consider this  to be a  bad code smell  that significantly
reduces the readability. Whole codebase turns into spaghetti.

*** Extra

- Linux [[https://github.com/nim-lang/RFCs/issues/58#issuecomment-442785793][is]] "fundamentally broken" and

  #+begin_quote
  dlopen  is widely  used by  Python, Ruby,  Perl, ...  what you're  really
  telling me  here is that your  OS is fundamentally broken.  That might be
  news for you, but it isn't for me.
  #+end_quote

  So using  native linker is  not a feasible option  -- proven by  the fact
  *dynamic* languages (TIL  Nim is a [[https://github.com/nim-lang/Nim/issues/9203#issuecomment-428201355][dynamic]] language,  right) use ~dlopen~
  so instead  it would be better  to just [[https://github.com/nim-lang/Nim/blob/1247043c9036fb6029c87bf5bed9021c6eff6092/lib/wrappers/openssl.nim#L337-L357][reimplement]] random  pieces of the
  linker and still resort to low-level [[https://github.com/nim-lang/Nim/blob/1247043c9036fb6029c87bf5bed9021c6eff6092/lib/wrappers/openssl.nim#L411][hacks]].




** TODO General issues with the management

** TODO Tooling implementation issues

[[https://github.com/nim-lang/RFCs/issues/300][Developer    tooling   ·    Issue   #300]]    ([[https://web.archive.org/web/20221024162725/https://github.com/nim-lang/RFCs/issues/300][archive]])   is    second   most
commented-on[fn:on-96] and third most-upwoted issue currently open issue in
the repository.  At the time of  writing [2022-10-24 Mon] it  has been open
for almost two  years -- added to  the 2021 milestone, then  described as a
/"the most important thing for me personally"/ thing in the [[https://github.com/nim-lang/RFCs/issues/437][roadmap]].

[fn:on-96] Second only to a [[https://github.com/nim-lang/RFCs/issues/456][Nim v2: get rid of style insensitivity · Issue
#456]] aka
#+begin_quote
Not because  style insensitivity leads to  bugs or any of  the other things
that those  unfamiliar with Nim  hypothesise but because  it is one  of the
main reasons that people do not even try Nim
#+end_quote
which gathered  a whopping 220  responses over  a topic that  is completely
dwarfed in importance  by the working developer tooling.  This question had
been raised four years ago as well on the nim forum [[https://forum.nim-lang.org/t/4388][Should we get rid of
style insensitivity?]] with no concrete results.

** TODO Project priorities and goal-setting

*** General project roadmap

[[https://github.com/nim-lang/RFCs/issues/437][Roadmap for  Nim ·  Issue #437]] had  been created only  after long  and ugly
[[https://forum.nim-lang.org/t/8627][discussion]] where core project developer apparently [[#= ][learned]] that

#+begin_quote
    It's good that I have a plan.
    Even better would be if I shared it with the community...
#+end_quote

Too bad the roadmap still did not include the, well, *road* component of it
-- specifically  how to  get to  the  point listed,  so  it was  more of  a
wish-list than a real roadmap. But that's something at least, and you would
be hard-pressed to  find /anything even resembling it/ for  the most of the
core project existence since 1.0.

*** Managing specific projects

**** c2nim

Nim interop a *big*  topic when someone starts using nim,  but it there has
never been  any official effort aside  from a *[[https://forum.nim-lang.org/t/8020][handwritten]]* C++  parser (if
you have any  knowledge of the subject  you should run away  already) and a
tool that requires you to [[https://github.com/nim-lang/c2nim/blob/master/doc/c2nim.rst#def-directive][modify]] the headers.

**** standard library
**** Nim forum

- [[https://github.com/nim-lang/nimforum/issues/180][searching posts by user should not be limited to 1st 10 posts/threads ·
  Issue #180 · nim-lang/nimforum ]]
- https://www.reddit.com/r/nim/comments/7smw81/comment/dt7xmab/
- https://forum.nim-lang.org/t/3534#22078
- https://forum.nim-lang.org/t/8852#57838

**** fusion

I  was  involved  in this  part  personally,  so  I'm  going to  provide  a
first-hand account in this specifically  I worked on the "official" pattern
matching implementation solution.

Back in 2020 ~@alehander92~ (author of  the Gara [[https://github.com/alehander92/gara/][library]], nil [[https://github.com/nim-lang/Nim/pull/15287][check]] feature
and many  [[https://github.com/nim-lang/Nim/pulls?q=is%3Apr+sort%3Aupdated-desc+author%3Aalehander92][other]] PRs) wrote  an [[https://github.com/nim-lang/RFCs/issues/245][RFC]]  about pattern matching.  Several months
later I  [[https://github.com/nim-lang/RFCs/issues/245#issuecomment-695780794][joined]] the discussion,  providing a starting [[https://github.com/haxscramper/hmisc/blob/f58838040170547e19c01bd6b9f3e42a16811f91/tests/tMatching.nim][implementation]]  and a
specification  that later  was [[https://github.com/nim-lang/RFCs/issues/245#issuecomment-697897542][expanded]]  and agreed  upon. At  this time  I
[[https://github.com/nim-lang/RFCs/issues/194#issuecomment-700994731][thought]] it should be a move  to consolidate the ecosystem. I [[https://github.com/nim-lang/fusion/pull/33][implemented]] it
for the fusion library  and it was merged after an  initial review.

At this point I thought that people can finally make use of it in different
scenarios, simplify writing macros and so on, writing my [[https://github.com/nim-lang/website/pull/252][first]] iteration of
the article. About  two weeks later fusion was [[https://github.com/nim-lang/Nim/pull/16925][unbundled]]  from the standard
library and  left on it's own  as a separate  package with an idea  it will
also [[https://github.com/nim-lang/fusion/issues/30][adopt]] semantic versioning (never really  happened). Then I had to wait
for over a month until by patience finally [[https://github.com/nim-lang/website/pull/252#issuecomment-786700979][ran out]] and I decided to publish
it  myself somehow.  Eventually it  was [[https://github.com/nim-lang/website/pull/271][published]],  received 145  points on
[[https://news.ycombinator.com/item?id=26420716][hackernews]]. In march someone made a video tutorial on the [[https://www.youtube.com/watch?v=GJpn6SfR_1M][library]].


Then nim 1.6.0 introduced the ~nnkTupleConstr~ - ~fusion/matching~ required
some  fixing, so  ~@clybber~ [[https://github.com/nim-lang/fusion/pull/86][fixed]]  it  in, so  far so  good. Except  after
unbundling never  received any  proper tags, and  people still  [[https://github.com/nim-lang/fusion/issues/99][get]] [[https://www.reddit.com/r/nim/comments/qfi1d0/fusionmatching_broken_in_nim_16/][version]]
that is nine months old. I  wasn't really privy into the management details
and simply worked on the [[https://github.com/nim-lang/fusion/pull/94][PR]] with additional fixes.

My PR had  a CI failing for  a five months purely  due to [[https://github.com/nim-lang/fusion/pull/100][misconfiguration]],
and I  had to personally  come and complain about  it in order  for leorize
(another person who moved to nimskull btw) to fix it.

After fixing CI -- Half a month forward, zero reaction. Is fusion a part of
the current  nim effort, or is  it not - I  don't know. Each time  it was a
waiting game, or I had to personally come and push people around so someone
even looked at my efforts, maybe even reviewed the code. No, five months of
silence with  dead CI,  no understanding  if my work  is even  needed, then
another half a month with fully green CI, and still no reaction.

Then "Preview of the coming attractions"  [[https://forum.nim-lang.org/t/8627][thread]] happened. I made the point
[[https://forum.nim-lang.org/t/8627#56155][above]], then got a fantastic exchange that I'm going to simply paste here in
it's entirety,  it is too  good to  slice and dice  into parts. I  will add
footnotes instead.

-------

*Araq*:

I'm really sorry for your bad experience and I hope you'll come back. Fusion is part of what we offer, it's however badly maintained as I get no emails from github when there is activity. I think I enabled the email feature, I'm not sure why I still don't get any. I also don't know why so few people appear to have the proper rights to merge things on Fusion, I'll see what we can do.

    So these are my two cents on how having a good roadmap could've prevented a almost a year's worth of effort (pattern matching) to not lose it's maintainer ...

Sorry, but that's not how I see it, since we are overburdened with work, the proper solution is to give you more rights so that you can go ahead and not be constantly blocked by us.


-------

*haxscramper*:

NO, the  proper solution is not  to give me  "more rights" - have  you even
read what I said about fusion and my PR?

#+begin_quote
Half a month  forward, zero reaction. Is  fusion a part of  the current nim
effort, or is it not - I don't know.  Each time it was a waiting game, or I
had to personally come and push people  around so someone even looked at my
efforts, maybe even reviewed the code. No, five months of silence with dead
CI, no understanding if  my work is even needed, then  another half a month
with fully green CI, and still no reaction.
#+end_quote


The solution is not  to give me more permissions in  hope I will accomplish
something without any supervision. Now I have even more responsibility, and
I  have  double-think  any of  my  decisions  -  are  they right,  do  they
contribute to the final goal (whatever it is). You just made situation even
worse - before I just doubted if my  work is needed, but now I also have to
constantly carry the  burden of even higher-level decision  making and face
decision paralysis with no clear common goal in sight.

#+begin_quote
Fusion is part of what we offer,  it's however badly maintained as I get no
emails from github when there is activity.
#+end_quote

It  is badly  maintained not  because  you don't  get emails,  it is  badly
maintained because  I'm yet to  see a  single finalized decision  about it.
Nobody understands it's status, and people can't really work in dark. After
we decided to unbundle it, it practically became an abadonware. I mean, for
half a year nobody  even looked at the CI - the  fix was absolutely trivial
except you  need to  know that "nim-lang.org  no longer  provides versioned
MinGW", which  I of course  had no idea about,  since I don't  use windows.
Well, I should've probably pinged you right there, right? Except

#+begin_quote
... but that's not how I see it, since we are overburdened with work ...
#+end_quote

And you  know, for  some weird reason  I'm not thrilled  about the  idea of
constantly  pinging  people who  say  stuff  like  this  with (and  have  a
perfectly valid reason to say this,  which is even more important). I mean,
my problem is not that important,  and I might distract them from something
actually important, so maybe  I just need to wait, I'm  sure they have some
kind of planning going on ..., right?

#+begin_quote
give you more rights so that you can go ahead and not be constantly blocked
by us.
#+end_quote

and turn  the language into  complete mess  by my misguided  decisions? No,
thank  you, I  do not  trust  myself enough  to make  decisions that  would
benefit everyone. Or I were supposed  to somehow build a sub-community with
whom I  can discuss  my decisions on  the implementation  details? Maintain
dedicated set  of issues on  pattern matching in  fusions, treat them  as a
sort of "local RFC" and basically  replicate the whole process on a smaller
scale?

-------

*Araq*:

Yes, I did read it, all of it. Yes, I do care about pattern matching and Fusion and I love your work on it.

#+begin_quote
It is badly maintained not because you don't get emails, it is badly maintained because I'm yet to see a single finalized decision about it.
#+end_quote

We don't  bundle Fusion with  Nim anymore  because that causes  yet another
"split" -- you can update it independently  from Nim, so if we also ship it
with Nim both of these modes must be tested and be ensured to keep working.
Ensuring that stuff keeps working can be surprisingly hard. Fusion also had
other design  mistakes, like  an unreasonable backwards  compat requirement
for code that is supposed to evolve.

A "finalized" decision would be easy:  Let's split up Fusion into different
packages,  there  can   be  nim-lang/pattern-matching,  nim-lang/threading,
nim-lang/javascript-wrappers,  nim-lang/xyz. The  problem?  It's really  as
mundane as setting up N Nimble packages plus the CIs plus ensuring that the
CIs stay green and that things work well together.

--------

*haxscramper*:

Making it a multitude of packages instead of one single package addresses none of the concerns I expressed above. It is just shuffling responsibility around, and further separating the efforts.

nim-lang/pattern-matching - It seems like my last idea was close enough

#+begin_quote
Or I were supposed to somehow build a sub-community with whom I can discuss
my  decisions on  the  implementation details?  Maintain  dedicated set  of
issues on pattern matching in fusions, treat  them as a sort of "local RFC"
and basically replicate the whole process on a smaller scale?
#+end_quote

I can do this, it is possible, but  what is the point even? I get nim-lang/
prefix for  the repo  and some sort  of the "official"  status? I  can just
maintain my own library, we have a PM so people can just require things.

--------

*haxscramper*:

With each  step we are  getting farther and  farther away from  my original
goal - not  in the stdlib because we should  use "upcoming" let expressions
(where  is a  roadmap). Not  in the  fusion because  maintainer's incentive
slowly withered away in complete silence. Now  the solution is to make it a
collection of packages in nim-lang/ organization.

--------

*haxscramper*:

#+begin_quote
I'm really sorry for your bad experience and I hope you'll come back.
#+end_quote

Sorry, but no, I sort of made up  my mind before hitting the "Reply" on the
first comment, since it  was not a trivial decision for  me, I really don't
like to burn the bridges.

Followed discussion just made it clear I no longer want to have anything to
do  with  fusion&related  -  I  will  just  dive  into  abyss  of  complete
uncertainty, I don't need any of that.

I will just  maintain my own library  - kind of sad all  my aspirations and
work effectively amounted to a xkcd comic

-----

*Araq*:

#+begin_quote
I can do this, it is possible, but  what is the point even? I get nim-lang/
prefix for  the repo  and some sort  of the "official"  status? I  can just
maintain my own library, we have a PM so people can just require things.
#+end_quote

Good points. But the "official" status is not marketing, it implies that the code got reviewed, that it is our recommended package, that it's covered by a CI, that it keeps working.

------

*haxscramper*:

Almost two weeks  later, fusion is not  tagged (surely it was  hard to do),
released roadmap does  not even mention it, nimble is  briefly described as
"We hope to  be able to ship a  new Nimble with the 2.0 release  but we are
happy to ship  it whenever it's ready." (probably my  RFC is either implied
as "you should  know about it" or something like  that, definition of ready
is not provided, no idea what state is it in now)

So I think that

#+begin_quote
I'm really sorry for your bad experience and I hope you'll come back
#+end_quote

Pretty much amounts to "I will pretend I care, but I really don't, and this is certainly not something worth mentioning on the roadmap"

-------

*Araq*:

#+begin_quote
released roadmap does not even mention it
#+end_quote


Fusion is  not part  of the  plan. You want  me to  make decisions,  I make
decisions, and then I make the wrong ones. It's inevitable.

#+begin_quote
nimble is briefly described as...
#+end_quote

Edit: I extended the section on Nimble a little bit.

------

*haxscramper*:

Main point was - two weeks after fusion is still not tagged and still breaks the code on 1.6, but since it is "not part of the plan" I guess this can be ignored.

-------

*Araq*

I could give you  the rights so that you can fix and  tag things on fusion.
But you didn't want that so instead you have to be patient.

------

*haxscramper*:

Maybe it  makes sense to just  admit fusion has absolutely  no maintainers,
and find someone who is willing to  do the job? Think about enabling people
to do the work  for you instead of singling out me  just because I happened
to raise the  problem. "you have to  be patient" - yes,  and everyone using
1.6.0 and unable to  compile basic example from the manual.  (by the way, I
said  I'm not  willing  to  shoulder the  responsibility  to  make the  API
decision  and  self-approve  them  without any  external  review,  this  is
different from being able to tag things. Latter one takes like five minutes
at  most,  and does  not  have  any  major  implications. Certainly  not  a
backbreaking effort, so if you want, you can give me permissions and I will
make this one-line commit).

-----

*Araq*

We released a  new version of Fusion. The next  time problems arise, please
use Fusion's issue  tracker. If you get no feedback  there, create an issue
on Nim's issue tracker instead.

------

Last [[https://github.com/nim-lang/RFCs/issues/476][discussion]]  about fusion talked  of its  deprecation. [[https://github.com/nim-lang/fusion/pull/16][PR]] took  about a
year to be reviewed.

So, to summarize -- in a span of about a month since I got my PR merged the
project  silently moved  from the  "official implementation"  to "we  don't
bundle it anymore" and then continued to rot from there.

** TODO Ecosystem and community health

*** TODO Repository issues

**** TODO Number of issues in the repository over time

**** TODO Average time to close the issue

*** TODO Repository pull requests

**** TODO Number of pull requests merged per day

**** TODO Percentage of the pull requests rejected/merged/stalled

# NOTE certain people will have different  rates of closing and opening the
# pull requests. I need  to know how many PRs did  Araq merge from himself,
# how many did he merge from dom96 and so on.

*** TODO Number of commits per period of time

# IMPLEMENT  split  number  of  interactions  with  certain  parts  of  the
# repository -- for example, commits that only touch a standard library are
# not especially interesting and can be ignored.

*** TODO Engagement of the core contributors in the repository

**** TODO Number of comments on various issues

**** TODO Number of commits

** TODO Financing and team management

Yes, money  talk. Although  I can't say  there is a  single instance  I can
remember that  can even be  characterize as  even /sketchy/, but  there are
more than a few loose ends I personally understand.

- Status  allegedly  finances nim  development,  but  I've never  seen  any
  official account  for this and judging  from some [[https://discord.com/channels/371759389889003530/371759607934353448/973912902903951382][remarks]] ("And  then how
  Status pays Araq  money is something for  him to explain if  he wishes, I
  know some  details but don't  want to make it  public in case  he doesn't
  want to.") it is not considered important enough to be discussed.
- Nim has [[https://nim-lang.org/blog/2021/10/25/nim-receives-100k-usd-bitcoin.html][received]] 100k in bitcoin  donations that then were transferred to
  this  [[https://www.blockchain.com/btc/address/1BXfuKM2uvoD6mbx4g5xM3eQhLzkCK77tJ][address]] and  subsequently split  into  [[https://www.blockchain.com/btc/address/bc1qzgw3vsppsa9gu53qyecyu063jfajmjpye3r2h4][these]] [[https://www.blockchain.com/btc/address/bc1qde22ua57hqvl36657mkx4x2gvwp5gn5xh34g6f][two]],  where the  money
  reside up to  this day. I've never  heard about any plans  to do anything
  with these  money, but  the USD value  had dropped by  a factor  of three
  since then.
- It is not really clear who actually works on the project full-time and is
  paid  core contributor,  who  is  just a  volunteer  and  who is  getting
  periodically [[https://opencollective.com/nim/expenses/97898][paid]] to work on a  specific [[https://github.com/nim-lang/RFCs/issues/437#issue-1058638395][tasks]] (most checkpoints had been
  closed by the ~@xflywind~).

* Part two: "nimskull"

There is no point denying that the project had started as a fork of the nim
programming language  compiler, but at  the same time  it is less  and less
relevant as time goes  on, because we want to move into  the direction of a
/better language/ not a /better reimplementation of a nim compiler/.

A  specific meaning  of  this  distinction will  be  provided  in the  next
section, here I will briefly talk  about some of the common misconceptions.
After this  article is  written I  will try  to update  the readme  text to
reflect the list.

* Part three: our deal

This  is  specifically  aimed  to provide  the  explanation  about  working
procedures in  the project,  explain the  value framework  that is  used to
decide what  is going to  be worked  on and what  is going to  be postponed
until a later date.

I  decided it  would be  better  to formulate  my  ideas on  this topic  as
precisely as I can, even if it might  sound harsher than it needs to be. It
probably will  never end up  in the official  readme, because that  sort of
wording and language is very unlikely to excite new contributors and users.

The most important notion that should be understood is that each project is
working off a  finite resource -- a  limited number of people,  who have an
finite amount of time they can dedicate. They don't want to have a /burnout
on the OSS/ projects and they want  to /work on the stuff they enjoy/.

At this  moment in  the goals  of the  project are  almost entirely  set by
contributor team  (as opposed to  being driven by external  requests). Said
team  decided that  it would  be the  best  user of  their time  to (in  no
specific order):

1. *DO  NOT* provide a LTS  version that keeps backward  compatibility with
   mainline nim.
2. *DO  NOT* /try/  to keep  the backwards  compatibility in  the following
   cases (and similar scenarios):
   1. If better language design emerges.
   2. If the feature had already been marked as deprecated in the mainline
   3. If the feature is implemented in form of opt-in language dialect
   4. If keeping the feature intact will require significant compromises on
      the code quality and maintainability.
3. *DO  NOT* hesitate  to make  a hard decisions  if it  would allow  for a
   large-scale cleanup to move forward.
4. *DO  NOT* spec  out bugs and  *DO NOT* solidify  bugs into  the language
   design.
5. *DO* work on the internal documentation, development history
6. *DO* work that improves the internal architecture of the compiler.
7. *DO* reduce the barrier of entry to the new contributors
8. *DO*   prioritize  the  consistent  language   design  over  occasional
  convenience.
9. *DO*  work on consolidating  existing language dialects into  a /single/
   language, not exponential number of possible flag combinations.
10. *DO* work  on specifying  exact  rules of  the aforementioned  /single/
   language.

Having read that a user can  decide for themselves whether *they think* the
trade-offs are acceptable  *for them*.

Personally, I  think it is important  to honestly set the  expectations and
adhere  to the  community  contract  you proposed,  rather  than trying  to
accommodate for every  single user from the old community.  Yes, that might
sound overly harsh, but  I don't want to move along  the =vlang= route with
over-promises and under-deliveries.

Three important  points that should  be emphasized  in regards as  to where
this list is relevant and where it is not:

1. The  list above explains the  principles under which we  operate when it
   comes to the decisions related  to the *implementation* and weighing out
   the  pros  and  cons  of  technical  decision.  Discussion  process  and
   community handling  are regulated  by the  Code of  Conduct and  Code of
   Ethics which take priority over all interactions.
2. The list should serve as a  breakdown of the developer team priority and
   served as  a first filter  that is used  to consider specific  ideas and
   requests.
3. It explicitly does not provide breakdown of a specific new feature-based
   objectives  in this  section. Current  part of  the work  is focused  on
   solving implementation issues with already existing features.

* Part four: our vision

In this  section I will  briefly outline a  general vision for  the project
moving forward. After more than a year of work it is a good idea to draw on
the newly discovered knowledge to help better define the direction.

This section does  not focus on the specific technical  details -- they are
provided in section five, "our scopes".

>>>>>>>>>>>>>

One of the most important goal is to make it easier for contributors on all
levels. Writing documentation and reorganizing the code is pretty good, but
there are lots of smaller things that improve quality of life. Attention to
details is important. You can continue  to keep the whole compiler codebase
in  one   folder  with  150+  files   or  you  can  separate   things  into
subdirectories based  on the respective  compiler subsystems. You  can keep
test suite as  a gigantic mess of ~t10489_a.nim~ files  that can be decoded
only if you  use git blame extensively  ... or you can spend  a fraction of
implementation efforts and  document what you've done and why  it should be
tested this  way. You can  keep adding various ~stdlib_misc~  tests, random
toplevel folders with a single test (TODO insert ~test.c~ link, link to the
gigantic ~stdlib~), misplaced tests (TODO insert ~collections~ link, stdlib
link), continue testing with ~echo~

https://github.com/nim-lang/Nim/tree/3469f37a56c31623eff473c65fd231bb5a77d5d8/tests/misc

<<<<<<<<<<<<<

* Part five: our scopes

In this section  I will provide a more technical  explanation about current
stage of the development, how it correlates with a vision from the previous
section ("our vision") and issues in the implementation "why".

This section  is mostly in line  with the near-term development  [[https://github.com/nim-works/nimskull#near-term-development][roadmap]] in
the  readme,  but  provides  a  lot more  historical  elaborations  on  the
implementation details.  I try  to keep  the most  relevant details  of the
reimplementation progress updated in the [[https://github.com/nim-works/nimskull/discussions/142?sort=new][thread]].

** Proper intermediate representation for compiler stages

*** Data-oriented design

*** Lexer data

*** Parser data

*** Error data

Mainline  implementation  of  the  compiler  handling  does  not  have  any
structured  form  of  the  error message.  Things  are  randomly  formatted
in-placed using multiple of variations of different

*** Semantic analysis data

*** Embedded virtual machine data

*** Backend data

** Removing language dialects

Mainline has  a large number of  language dialects that affect  how code is
compiled  and what  features  are  available which  can  cause issues  when
enabled. Having  separate language dialects causes  combinatorial explosion
in testing  (~on/off~ test for each  flag, sometimes there are  more values
that  can be  allowed)  and some  things are  inevitably  fall through  the
cracks.

All  experimental  features should  either  be  implemented completely  and
enabled by default (such as "strict  funcs", "not nil" checking) or removed
from  the  implementation.  Optimizing  for  "what  if"  use  case  is  not
sustainable in the long run as  it disperses the efforts and requires large
amount of time to coordinate different parts of the language.

** Structured C and C++ interop

Right now  C and C++ interop  largely relies on the  fact backend generates
code listings and not binaries. This  makes it possible to have things such
as  ~{.emit.}~ and  various ~importcpp~  patterns. Compiler  does not  know
anything about the structure of the C++ code that is being wrapped and user
can trick it with things like  ~#.__karaxMarker__ = true~, but generally it
is not needed. Overwhelming majority of the patterns

# rg -g "*.nim" --no-filename --no-line-number --only-matching 'importcpp:\s*".*?"' |
#     sd 'importcpp:\s+"' '' | sd '"$' '' | sort | uniq  > importcpp

*** Problem

- TODO compiler has no understanding  of the FFI structure, code templating
  has hacks,  99% of the  times it  is used for  trivial cases that  can be
  covered  by an  interface  file,  everything else  is  either covered  by
  ~{.emit.}~  or should  just  be  separated in  different  pieces of  code
  altogether.

*** Current state of the ecosystem

Simple  analysis of  different  ~importcpp~ patterns  shows  that they  are
*overwhelmingly* used  to account  for a number  of simple  patterns listed
here:

TODO document/explain patterns.

#+begin_src js
/^#?(->|\.|\.~|new\s)?[a-zA-Z0-9_:]+(\((@|#)?\))?$/d
/^\(?#\s*(\|\||&&|>=|<=|<<=|>>=|==|<<|>>|<|>|[-+*%&/~]=|=[-+*%&/~])\s*#\)?$/d
/^\(?#\s*[+*/%&-|^]\s*\)?#/d
/^([a-zA-Z_:]+\.?)+$/d
/^\(?(\+\+|\-\-|[-~*&!]|new)\s*(#|@)\)?$/d
/^#\(@\)$/d
/^#\[(#|@)\]$/d
/^\(#\)$/d
/^delete @$/d
/^#.[a-zA-Z_:]\*=\*#$/d
#+end_src

Cloning all packages in the list  using code listing below and then running
simple ~rg  | wc -l~  shows that number  of ~importcpp~ patterns  listed is
14503 (12490 unique).

#+caption: Clone all nimble packages
#+begin_src elvish
set E:GIT_TERMINAL_PROMPT = 0
for url [(cat packages.json | jq '.[].url' --raw-output)] {
    try {
        git clone $url".git"
    } catch {

    }
}
#+end_src

#+caption: Count importcpp uses
#+begin_src elvish
rg -g "*.nim" --no-filename ^
    --no-line-number --only-matching 'importcpp:\s*".*?"' |
    sd 'importcpp:\s*"' '' | sd '"$' '' | wc -l
#+end_src

Removing common patterns we get 274  (223 unique), which is ~0.018%~ of the
total number. And  large number of these patterns is  not exactly "special"
either:

#+caption: Filter out common patterns
#+begin_src elvish
rg -g "*.nim" --no-filename --no-line-number --only-matching 'importcpp:\s*".*?"' |
    sd 'importcpp:\s*"' '' | sd '"$' '' | sed -r -f importcpp_remove.sed
#+end_src

#+caption: Some of the more trivial examples that weren't matched by sed
#+begin_example
std::basic_string<'*0>(@)
std::pair <'0,'1>
std::make_shared<'*0>(#)
std::vector<'*0>(@)
at::detail::getCUDAHooks().compiledWithCuDNN()
#+end_example

There are, however, some very questionable constructs such as

#+caption: Unusual code
#+begin_example
std::shared_ptr<'*0>(@, []('*0* ptr) { callCppPtrDestructor(ptr); nimPointerDeleter(ptr); })
std::unique_ptr<'*0, std::function<void('*0*)>>(@, []('*0* ptr) { callCppPtrDestructor(ptr); nimPointerDeleter(ptr); })
_InterlockedExchange(reinterpret_cast<LONG volatile *>(#), static_cast<LONG>(#))
fetch(#, #).then(r => r.json())
(window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB)
#+end_example


# Funnily  enough,  the  only  ~grep   -F  "#.operator"~  found  in  code  is
# ~#.operator=()~.

*** Solution

Instead  of relying  on fragile  and repetitive  ~importcpp~ patterns  that
completely loose  the structure  of the  library to be  wrapped we  need to
introduce  an  /interface  file/  concept.  Interface  file  would  contain
description of  the library  API in  a declarative  manner. The  concept of
/declarative/ wrapping description had actually been considered seven years
ago in [[https://github.com/xomachine/wraptool-cpp2nim][GitHub - xomachine/wraptool-cpp2nim: Macros allowing generating
compact and readable wrappers to C++ classes for Nim programming language]]
but sadly didn't gain that much traction.

Main purpose  of the interface  file is  to /present information  about the
library in  a structured way/.  Interface file can  either be a  product of
automatic  wrapper  generator  or  a result  of  manual  effort.  Interface
description is less laborious compared to the manual ~importcpp~ annotation
as it  reduces the  need for repeated  namespace and  ~header~ annotations,
makes patterns themselves simpler as well.

In addition  to several  minor quality-of-life improvements  interface file
could also  be used as a  source of information for  further automatization
such  as   ~newClass()~  and  ~initClass()~  method   generation,  GC-aware
constructor  calling  (using  placement   new)  and  even  customized  code
generation. All of this will be possible if writings are made structured.

# https://matrix.to/#/!MAXxvfCYnfYgZqSizw:matrix.org/$xQc8dhoTg3rHL4xbF6OlHKVyQegSwHm9cRRUfO0ZX4k?via=libera.chat&via=matrix.org&via=matrix.shaggypeak.com

** Code formatting solution

Official stance on  the improvement of the code  formatting solutions seems
to be somewhere in the neighborhood of "just format the code manually".

#+caption: IRC [[https://irclogs.nim-lang.org/17-07-2019.html#10:27:47][logs]]
#+begin_quote
teach a system without eyes how to make code visually appealing, how hard can it be?
#+end_quote

The  fact that  most  major  languages seem  to  have  solved the  problem,
sometimes even multiple times suggest that it is not so "hard" to implement
after  all. The  main issues  seems  to be  rooted  in the  lack of  proper
intermediate representation in the compiler.

*** Problem

~nimpretty~ itself is a fairly simple  tool. Implementation leaves a lot to
be  desired -  currently it  is  hacked into  ~parser.nim~ and  ~lexer.nim~
directly, with  multiple (total  of ~37  and ~23  respectively) conditional
compilation checks like

#+begin_src nim
  if p.tok.tokType in {tkCurlyDotRi, tkCurlyRi}:
    when defined(nimpretty):
      if p.tok.tokType == tkCurlyRi: curlyRiWasPragma(p.em)
    getTok(p)
#+end_src

This makes it really  hard to provide a global code  layout, leading to bad
formatting -- if the tool does  not even understand the code properly there
is no hope it would be able to format it in any reasonable manner.

*** Solution

Code formatting  should first get a  concrete syntax tree --  one that does
not loose positional and structural information  -- and then format it back
into the source code. We already  [[https://github.com/nim-works/nimskull/pull/361][implemented]] the code layout algorithm and
continuing the work in this direction.

** Improving testing workflow

The  "language" project  consists  of several  parts  that are  effectively
layered on top of each  other -- core language primitives, metaprogramming,
external  libraries  and  so  on.  Test  suite  must  also  follow  layered
structure.

*** Language specification

TODO Core part of language specification

*** Additional feature tests

TODO Extra tests that provide required secondary safety net

*** Ensuring the code written in the language works

From the end  user perspective the ultimate objective of  the compiler test
suite  is to  ensure the  language will  not suddenly  break at  unexpected
places. In  order to support this  need core maintainers should  adopt some
kind of strategy.

Different  programming languages  have different  levels of  strictness and
guarantees when it  comes to backward compatibility and  ranging degrees of
attention  to  keeping  existing   code  working.  Some  languages  provide
specification that explicitly codifies what  the language *is*. Others have
a (reference)  implementation with accompanying test  suite which specifies
its  behavior in  different circumstances.  In that  case stability  of the
language largely depends on the test suite.

Mainline  uses a  combination of  language specification  and a  test suite
augmented by so called "important packages"  -- a list of external packages
whose tests are executed as a part  of CI run. This approach allows to keep
the "important"  part of the  ecosystem working  while making it  easier to
neglect writing tests  because it is easy to assume  that implementation is
/sufficiently tested/.

We want  to avoid  this inverse  dependency and instead  focus on  the core
tests as much as possible. The workflow for handling incoming issues should
be:

1. Someone discovers  a new implementation issue or  regression and reports
   it.
2. Test author should first consider if the problem signifies a hole in the
   specification.

   For example, if the issue is "FEATURE1 combined with FEATURE2 break when
   GC  is  used  on  BACKEND"  then  corresponding  specification  test  is:

   - "FEATURE1" works, "FEATURE2"  works, on all targets  and all backends,
     *or*
   - "FEATURE1 and FEATURE2"  can be combined in such and  such way. On all
     backends, for all garbage collectors

   As mentioned previous section ("Language specification") there can be no
   single way of writing tests so author should use common sense.

3. If it is  not possible to write a specification test  then a regular one
   is  created.  Problematic  snippet  should   be  reduced  and  added  to
   appropriate subdirectory in the test suite.

As you can see specification itself  should be enough -- all relevant parts
of the language can  be specified in an orthogonal way  and then there will
be no need for  an extra safety net. In theory.  In reality secondary level
of   tests  makes   it  possible   to  account   of  deficiencies   in  the
implementation: no matter  how orthogonal the language design  is there are
bound to be bugs, architectural issues  and so on. Additional feature tests
are designed to account for this.

"important packages" could've provided a tertiary layer of safety, but they
create  an  inverse  dependency  that  incur  unjustifiable  slowdowns  and
questionable [[https://github.com/nim-lang/Nim/commits/devel/testament/important_packages.nim][fiddling]] with the package list:

- [[https://github.com/nim-lang/Nim/pull/18292][disable pkg manu by timotheecour · Pull Request #18292 · nim-lang/Nim ·
  GitHub]]
- [[https://github.com/planetis-m/manu/issues/5][manu breaks important_packages · Issue #5 · planetis-m/manu · GitHub]]
- [[https://github.com/fowlmouth/nake/issues/77][nake breaks manu which breaks important_packages · Issue #77 ·
  fowlmouth/nake · GitHub]]
- [[https://github.com/nim-lang/Nim/commit/83128f217f63045974a48e61b65386abbfc97352][disable testing of `fidget`, to make CIs green · nim-lang/Nim@83128f2 ·
  GitHub]]
- [[https://github.com/nim-lang/Nim/pull/18601][fixes #18543 by Araq · Pull  Request #18601 · nim-lang/Nim · GitHub]] (note
  [[https://github.com/nim-lang/Nim/pull/18601#issuecomment-889381407][ignored]] commit message improvement suggestion)

* Part six: my vision

#+begin_center
Why *I* decided to contribute to this specific project.
#+end_center

I've already provided  most of the historical context I  could get my hands
on, so in this  part I'm instead going to focus on  the my personal account
of working for nimskull.

* Part seven: my scopes
  :PROPERTIES:
  :ID:       df3bccc6-1850-4ad1-85ff-44776c59f15c
  :END:

As a  contributor to the project  I have some  ideas of my own  that either
haven't been  in the discussion  for a long time  or too fuzzy  to properly
place on the roadmap. I will  discuss them in the following section, adding
to the master plan from the part five.

In  most cases  they  have  already been  discussed  /somewhat/ in  various
places, but are currently too far from the present state of things.

** Standard library

https://matrix.to/#/!alsWvZtOfWkQlHwcHC:envs.net/$_Kp6CVZzg7CEFIG55dWU11I5vyi9dAphJj89dzYnypo?via=libera.chat&via=matrix.org&via=matrix.shaggypeak.com

** Documentation generation

*** Problem

Specific features of the documentation generator have always been a notable
pain point for me  with respect to the ~nim doc~  command. Some people have
already ([[https://gradha.github.io/articles/2015/08/sad-ways-documentation-generation-tools-suck.html][Sad ways documentation generation tools suck - Rants from the
Ballmer Peak]]) voiced ([[https://github.com/nim-lang/RFCs/issues/447][Split documentation generation for easier tooling
and better jsondoc · Issue #447]]) their ideas and concerns. Missing pieces
include

- Ability to sort generated documentation in any way -- entries are grouped
  based on the macro/iterator/proc/func/template/method/type basis and then
  sorted alphabetically.
- Incredibly  verbose  system of  the  internal  references that  makes  it
  largely unusable for any sort of complex linking.

  In order to link the type somewhere you  need to spell out a full name of
  the  procedure with  all of  its argument  types. Now  imagine trying  to
  casually write documentation for some internal compiler module and having
  to link /this/:

  #+caption: pickBestCandidate is a semcall.nim function
  #+begin_src nim
proc pickBestCandidate(c: PContext,
                       headSymbol: PNode,
                       n: PNode,
                       initialBinding: PNode,
                       filter: TSymKinds,
                       best, alt: var TCandidate,
                       errors: var seq[SemCallMismatch],
                       flags: TExprFlags) =
  #+end_src

  Note -- the whole  codebase has a single procedure with  this name, so it
  is entirely possible to just resolve it from the name alone.

- It  is not  possible  to  get structured  output  from the  documentation
  generator. Produced 'structured' json  internally contains formatted HTML
  pieces instead of a structured information.

- Documentation generation happens in a single run, with ~runnableExamples~
  handled in a non-parallel way. Syntactic  errors in a single comment fail
  the whole  project build and so  do runnable examples. Running  either of
  the  source  code  pieces   below  with  src_sh{nim  doc  --errormax=1290
  file.nim} will  cause compilation  to fail  on a  first invalid  piece of
  code.

  #+caption: Syntax error in the documentation
  #+begin_src nim
proc bad*() =
  ## *??

proc thing*() =
  ## *?
  #+end_src
- Implementation of the documentation generator is pre

*** Solution

Just as most of the other core tools documentation generator lacks any form
of  intermediate  representation  that  can  be used  to  easily  create  a
structured  output.  Things  are  often  [[https://github.com/nim-lang/Nim/blob/daf35c6d1b4bc1377bf278aa265dab30c9f5867e/compiler/docgen.nim#L1204][formatted]]  in-place  or  converted
[[https://github.com/nim-lang/Nim/blob/daf35c6d1b4bc1377bf278aa265dab30c9f5867e/compiler/docgen.nim#L1117][directly]] from ~PNode~ [[https://github.com/nim-lang/Nim/blob/daf35c6d1b4bc1377bf278aa265dab30c9f5867e/compiler/docgen.nim#L1108][to]] json, HTML or LaTeX with [[https://github.com/nim-lang/Nim/blob/daf35c6d1b4bc1377bf278aa265dab30c9f5867e/compiler/docgen.nim#L379][two]] [[https://github.com/nim-lang/Nim/blob/daf35c6d1b4bc1377bf278aa265dab30c9f5867e/compiler/docgen.nim#L477][hardcoded]] [[https://github.com/nim-lang/Nim/blob/daf35c6d1b4bc1377bf278aa265dab30c9f5867e/compiler/docgen.nim#L515][outputs]].

Lack  of IR  is an  obvious  issue that  prevents  any sort  of the  output
customization.  A  better  solution  would be  to  have  some  intermediate
machine-readable format  that can then  be converted into  a human-readable
output.  Because  documentation generator  effectively  needs  to create  a
database of the whole project the  most obvious solution would be to create
an sqlite database from the code.

*** Extra features that solution would enable

- Because public API can now be  stored in a fixed-format database it might
  be  possible to  determine the  differences between  two versions  of the
  public API.

** Package management solution

*** Problem

Putting aside many different implementation, UX and ideological issues with
nimble that I already outlined in  the previous section, the most important
one is the philosophy it tries to impose on the user. Fundamentally it says
that there should be only one command  nim user should use and it should be
~nimble~. Install packages,  compile the code, run the code,  test the code
and so on. There is a lot of  information that you can't get out of nimble,
even in the ~.nimble~ script.

- If you  have a  custom ~test~  target and want  to get  the full  list of
  packages in the same way as a native ~test~ does -- it is not possible.
- If you want to run an extra  tool, such as ~testament~ for your tests and
  pass the list of the packages nimble  knows about -- you can't, this data
  is not exposed.

*** Package manager assumptions solution

Key  ideas of  the package  management  solution is  that *package  manager
manages the environment* and *if the environment hasn't changed the package
manager does not need to run*.

There  is already  a notion  of the  "environment" via  ~nim.cfg~ that  can
specify  the   ~--path="<package  path>"~  configuration  options   to  the
compiler or any other tool that can be put in the compilation pipeline.

- A package  manager to  manage your  package installation.  Downloads your
  packages  and   resolves  things   using  information  provided   by  git
  submodules.  When version  conflict occurs,  we use  the MVS  strategy to
  resolve which version of the library you  end up getting in the end. When
  the package  manager finishes  execution, you are  left with  a ~nim.cfg~
  file  that   contains  ~--path:~  parameters  with   specify  where  each
  dependency was installed in the end.
- ~<build  tool>~ that  might  be  used after  package  download stage  has
  finished. At  this point  it is  used to finish  the installation  of the
  packages  -  for some  libraries  it  might  be  needed to  perform  some
  additional actions, like building ~.so~.
- After  all  of your  packages  are  correctly  (1) *downloaded*  and  (2)
  *installed*, you can start compiling your code using nim compiler.

*** Dependency resolution algorithm solution

There  are many  counterpoints  to the  minimum  version selection  package
managers, most of  which talk about how things are  "usually" done and that
it "does not  make sense" or "nobody would manually  upgrade the packages".
Most of them effectively  boil down to the fact that =MVS=  is not the best
tool for every single workflow, which is perfectly understandable.

There  are  also   several  considerations,  both  of   the  technical  and
ideological  nature  that  are  involved  in  decision  about  how  package
management is done.

- First  and foremost  -- /proper/  implementation of  the maximum  version
  selection  is  a  complicated  task  because  the  problem  itself  is  a
  NP-complete. There have  been [[https://github.com/nim-lang/nimble/issues/890][discussions]] about using  a better algorithm
  for the resolution,  but it is still pretty  sophisticated, [[https://nex3.medium.com/pubgrub-2fb6470504f][especially]] if
  you want to get a [[ for the resolution failures][good]] UX.

  Minimum  version selection,  on the  other hand,  is a  trivial and  very
  predictable algorithm that  can be written in a hundred  lines of code or
  so.
- Second -- usage  of the =MVS= would require package  authors to be honest
  with what  their requirements are. If  you actually need the  ~0.4.0~ and
  not the ~0.3.0~ you should no longer rely on the implicit assumption that
  PM will "do the right thing".
- Thirdly -- package manager won't suddenly pull a different version of the
  dependency unless you explicitly specify it can do so.

*** "Single tool" solution

In several cases the importance of a single tool, which can perform all the
project-related activity, has been emphasized. Go has often been used as an
example.  Solution above  is completely  orthogonal to  this request  as it
would be trivial  to provide a main  driver program, in the  same manner as
~clang++~ is a driver on top of multiple smaller execution actions.

Keeping things separate on the implementation level still allows to provide
a unified  interface that would even  support a user-provided actions  in a
manner similar to the ~git~ subcommands.
