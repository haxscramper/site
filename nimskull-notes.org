#+title: Why nimskull
#+options: broken-links:mark toc:4 ^:nil
#+latex_class: article
#+latex_header: \include{latex_conf.tex}

# #+latex_header: \usepackage{fontspec}
# #+latex_header: \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
# #+latex_header: \setmainfont{Times}
# #+latex_header: \setmonofont{Lucida Sans Typewriter}
#+latex_compiler: xelatex

# TODO https://matrix.to/#/!alsWvZtOfWkQlHwcHC:envs.net/$InF0jWs3VKmmsZTRa_lzWKMyNQXsdcdJanLunNsTlqc?via=libera.chat&via=matrix.org&via=matrix.shaggypeak.com add discussion insights from the discussion

# TODO  how  often each  line  in  testament/important packages  have  been
# edited.  How long  has  drnim been  staying in  the  compiler code  base.
# Interesting attitude for the "code rot" implementation.

After another round  of discussions about possible  objectives, reasons and
merits of the Nim fork I've been working  on I decided to write down my own
thoughts on this matter, elaborate  on the decision-making process that has
led to the specific wording of the readme.

---------------------------------------------------------------------------

Disclaimer: this  article is going  to have a  lot of disclaimers  down the
road, but  ultimately I admit  the attempt to  write it in  the "objective"
manner failed,  since I have too  much personal investment in  the issue. I
tried to keep the tone in check, but you can never be completely sure.

---------------------------------------------------------------------------

Some parts of this article are going to be outdated in the future -- mostly
stuff  concerning PR  aspect of  the  project, how  we advertise  different
elements of it and so on. If  there are going to be any fundamental changes
I will update this text accordingly.

---------------------------------------------------------------------------

To save you  some time, my top  picks when it comes to  spreading FUD about
nimskull are the following, in order of my preference:

1. /"Well good luck hard-forking backwards into the past to re-write commit
   messages."/ ([[https://news.ycombinator.com/item?id=32033473][link]]  and I'm /still/  really puzzled  as to what  the hell
   does that  mean, so if you  want to FUD  in comments *and* use  this one
   *and* can explain it -- I will be really glad to see you)
2. /"Forks  that seem to  exist for no  clear reason other  than disgruntled
   person(s) thumbing their nose at an upstream maintainer never do."/
3. /"So, nimskull is a project management exercise, carry on then"/

* WIP Part one: "why"
  :PROPERTIES:
  :ID:       29e7b85f-c637-4f8a-b9a6-c594f9fe833d
  :END:

Important  disclaimer before  I  go  into long  and  annoying  list of  all
failings that  happened over the  years --  I *personally* think  that this
sort of conduct  is bad and poorly reflects on  the community health. There
might be other points of view, either on specific issues or in general.

Some might consider  a missing Code of Conduct a  major problem, some might
be hell-bent  on a [[https://forum.nim-lang.org/t/9511#62471][multiple]] instances  of a very unwelcome  language, weird
[[https://forum.nim-lang.org/t/9402#61840][rhetoric]] and so on, but I included things that I, *personally*, consider to
be important.

---------------------------------------------------------------------------


Most common questions concerning "why" aspect  of the project I've seen can
be summarized in the following phrase: "why fork if you can just contribute
to the mainline" or  "why not contribute to the mainline".  There are a few
things in this sentence that need to be unpacked, specifically in the first
variant of it. It  is not always used in this literal form,  but I saw that
formulation often enough to go into the sentence dissection mode.

Let's get  the most  obvious and  irritating response out  of the  way. The
response to *"why do X"* is pretty simple: "because I'm a free person to do
what I want with my free time". So I decided to work on the fork instead of
a main project.

Of course this is just a blanket  "buzz off" response that does not address
the important  questions, but I decided  it is important enough  to warrant
the inclusion.

Second and a lot more controversial response targets the *"just"* word. I'm
sure there are  realms of irritated blog posts, articles  and books written
about "why don't you just do X" and how often it is not all that easy.

Before I go into long detailed list of what is wrong with the mainline, I'm
going  to say  that we  (nimskull contributor  team) explicitly  decided to
*not* to include these sort of historical elaboration in the readme because
it does not  generally help the discussion. Instead of  looking forward and
deciding what do next the discourse  is focused on seeking someone to blame
for various issues.

I've contemplated the idea of writing this  kind of article for a long time
and after about  a year of hearing various questions,  ranging from genuine
confusion (e.g. newcomer  to the mainline gets disoriented  about status of
each projects and  seeks some elaboration) to a commonplace  HN FUD that is
based on the quick skim of the readme.


https://discord.com/channels/371759389889003530/371759607934353448/915902483086323732

https://discord.com/channels/371759389889003530/371759607934353448/915895070803243008

https://discord.com/channels/371759389889003530/371759389889003532/910564109764935781

https://discord.com/channels/371759389889003530/371759389889003532/910579516903157781

https://github.com/nim-lang/nimble/pull/913#issuecomment-873565439

https://discord.com/channels/371759389889003530/371759607934353448/915916352450088961

> the delete circus with nimStrictDelete is something I will probably never understand

** TODO Issues with the implementation

This section outlines what is wrong  with the current implementation -- for
our solutions to fixing the problems see the "our vision" section below.

*** Technical introduction

Before  discussing issues  with the  implementation it  would be  more than
appropriate  to  provide  brief  overview  of  the  implementation  because
understanding some of the issues  requires either hands-on experience or at
least basic familiarity with the problem domain.

**** High-level compiler architecture

Mostly aimed  at people  unfamiliar with how  compilers are  implemented in
general  and how  nim is  implemented specifically.  Relevant parts  of the
source code are linked  from the text (TODO). The links  are absolute (to a
specific version of the file) to avoid potential bitrot in the text.

Nim compiler  has a  classic compilation  architecture, split  into several
high-level  stages:  tokenization,  parsing,  semantic  analysis  and  code
generation.

***** Tokenization

Splits input source file into series of smaller text units which are called
tokens. Each token has it's own  *kind* and value. There are many different
kinds  of tokens,  such as  "identifier" (variables,  argument names,  type
names),  "keyword"  (~for~,  ~while~,  ~if~ and  so  on),  "literal"  (~1~,
~"test"~ in code)

***** Parsing

Sequence of input tokens  is turned into a tree structure TODO expand more?

***** Semantic analysis
      :PROPERTIES:
      :ID:       6581011d-ea28-42ec-bc38-f5d070aed1bf
      :END:

Parsed tree structure is processed further and more information is added to
it (identifiers are turned into symbols and assigned types, expressions are
simplified) and metaprogramming actions are executed.

Mainline implementation implements all steps of the semantic analysis using
[[https://github.com/nim-lang/Nim/blob/fe43f751eb9a83f84cc93aa0d752c3658232002d/compiler/ast.nim#L779][~PNode~]] type. TODO explain structure

This part of the compilation pipeline has several important steps

- Macro expansion  :: Macro  and template  calls are  repeatedly expanded
  into a new AST. TODO

  Macro execution is performed using embedded virtual machine

- Constant folding :: Constant expressions  in code that can be evaluated
  are turned into simple literals. TODO example
- Lifting lambdas :: TODO
- Destructor injection :: TODO

***** Code generation

After all  parts of  the semantic  analysis are  complete resulting  AST is
turned into backend code.

***** Compiler-wide

Several  important things  can happen  during any  part of  the compilation
pipeline:

- Diagnostics reporting :: Any part of the compilation pipeline can issue a
  diagnostic message (hint, warning or  error) that might potentially abort
  the whole compilation process.
- File import  and include ::   External module import process is performed
  during semantic analysis and can  effectively switch the current "active"
  part of the compilation process.

*** Handling of the community requests

Nim-lang conducts a  yearly community survey with results  available on the
blog. [[https://nim-lang.org/blog/2022/01/14/community-survey-results-2021.html][2021]], [[https://nim-lang.org/blog/2021/01/20/community-survey-results-2020.html][2020]], [[https://nim-lang.org/blog/2020/02/18/community-survey-results-2019.html][2019]], [[https://nim-lang.org/blog/2018/10/27/community-survey-results-2018.html][2018]], [[https://nim-lang.org/blog/2017/10/01/community-survey-results-2017.html][2017]], [[https://nim-lang.org/blog/2016/09/03/community-survey-results-2016.html][2016]]. Some questions persisted over the
years.

#+caption: "Top/High", "Medium" and "Low/Ok" priority
| Question             | 2021     | 2020     | 2019     | 2018 | 2017 | 2016 |
|----------------------+----------+----------+----------+------+------+------|
| Fixing compiler bugs | 68/20/12 | 55/28/17 | 55/26/20 | N/A  | N/A  | N/A  |
| Improving tooling    | 49/29/22 | 43/30/26 | N/A      | N/A  | N/A  | N/A  |
| Documentation        | 40/36/24 | 42/30/28 | 50/26/24 | N/A  | N/A  | N/A  |

As you  can see,  over last  two years number  of respondents  who consider
current  implementation  acceptable  in  terms  of  bugs  decreased  almost
twofold, from  20% to 12%,  while the number  of those who  consider fixing
compiler bugs to be of high  or critical importance increased by 13%. Prior
to 2018 this question was not being asked.

Priority of  the tooling  improvement had  been asked  only twice,  but the
declining trend is present here, although not as drastically.

Documentation quality is steadily improving year-over-year.

*** TODO Compiler documentation

**** TODO Lack of the literal documentation

Large  parts of  the  compiler  codebase are  not  properly documented  and
explained.

**** TODO No high-level overview of the compiler internals

**** TODO The code is still effectively owned by a single person

*** Error messages

I've written several RFCs regarding  error message formatting and handling:
[[https://github.com/nim-lang/RFCs/issues/323][Compiler error suggestions · Issue #323]], [[https://github.com/nim-lang/RFCs/issues/324][Structured compilation errors ·
Issue #324]],  [[https://github.com/nim-lang/RFCs/issues/325][Type mismatch errors ·  Issue #325]] so I  will briefly rehash
the issues  regarding user-facing side of  things and implementation-facing
side. To the error quality RFC I got a lovely response

#+begin_quote
Feel free to improve the compiler's error messages. There is not much to disagree here with. (For me the error messages are good enough but I don't use mapIt nor noSideEffect.)
#+end_quote

It took  approximately two months of  work, almost twenty thousand  line of
changes in  173 compiler files  and significant  help of the  several other
contributors to  [[https://github.com/nim-works/nimskull/pull/94][provide]] a  /basis/ for further  error improvements.  And I
that  was  preceded  by almost  a  year  of  bashing  my head  against  the
implementation of the compiler in order to make sense out of it.

- Function  call  resolution  failures  were  created  with  little  to  no
  consideration to the  formatting quality. Things are  simply formatted as
  strings, [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/semcall.nim#L264][sorted]] in an alphabetical order and printed out.
- Error  messages themselves  are implemented  using almost  every possible
  solution, including direct string [[https://github.com/nim-lang/Nim/blob/4728c52c787b19c60a5533e20b7d71ee9ca137a3/compiler/semstmts.nim#L51][formatting]] and [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/semcall.nim#L413][concatenation]] (sometimes
  with [[https://github.com/nim-lang/Nim/blob/5602183234f59ece4fd668915da848f0753cbbb9/compiler/pragmas.nim#L116][raw]] [[id:6581011d-ea28-42ec-bc38-f5d070aed1bf][~PNode~]]  renders -- remember these lovely "but  expression has a
  type" with ~mapIt~ results), [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/msgs.nim#L577][formatting]] [[https://github.com/nim-lang/Nim/blob/5602183234f59ece4fd668915da848f0753cbbb9/compiler/lineinfos.nim#L106][enums]], formatting from the [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/semcall.nim#L280][consts]]
  that are indistinguishable from the enums but for some reason were placed
  separately.
- Current "new" idea  of the ~nkError~ never went [[https://github.com/nim-lang/Nim/search?q=nkError][anywhere]]  (link to the GH
  search  --  at the  time  of  writing it  shows  only  five uses  of  the
  ~nkError~) after it had been [[https://github.com/nim-lang/Nim/commit/cfff27529e4ec129daad602d945a2b222145e922][added]].
- It is not possible to get errors  in a structured manner, one that can be
  used for testing without  hardcoding current rendering format. Separation
  of data and presentation  -- not that hard of a concept  to grasp, yet to
  this day,  if you  need to  change even  a single  character in  an error
  formatting, you also need to go and update all tests suits that have this
  error. Each time.
- There  is no  encouragement of  the incremental  error improvements,  and
  thanks to  the necessity to  edit the test suite  each time it  becomes a
  major chore.

***** Random hacks all over the place

Proliferation of hard-to-spot hacks that  are at best sparingly documented,
at  worst  require  a  lot  of  guesswork  got  figure  out.  For  example,
[[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/lexer.nim#L887][lexer.getSymbol]] [[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/lexer.nim#L923][uses]] enum ~ord()~ and ~PIdent~ id addition (or [[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/lexer.nim#L934][subtraction]])
in order to  figure out the kind  of the token. Why are  identifier ids are
guaranteed to be mapped to  tokens? Maybe because ~newIdentCache~ [[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/idents.nim#L114][fills ids]]
at the  start with values from  the [[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/wordrecg.nim#L17][~TSpecialWord~]]? But how  latter enum is
related  to the  [[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/lexer.nim#L37][~TokenKind~]]  we are  trying to  figure  out? (they  /look/
similar, but is that  intentional?) Why do we need to  [[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/lexer.nim#L896][hash]] the token value
in the ~getSymbol~? Why do hashing in the ~getOperator~? Can't we just keep
a map ~token-string -> token-kind~ conversion?

Kludges are thrown  on each other all over the  place ~Token.iNumber~ is an
integer  literal  of   a  token,  according  to   the  [[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/lexer.nim#L101][documentation]]  (BTW,
single-hash-comments are not processed  by the documentation generator, yet
compiler uses them  for docs anyway -  as you can see in  the linked file),
but it is  also a (1) place to  [[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/lexer.nim#L441][split]] user numerical literals at  and a (2)
[[https://github.com/nim-lang/Nim/blob/f433d9cccf1a05da1a24e9fed9b914b7a2a35945/compiler/lexer.nim#L1094][number]] of newlines in the comment token

When an  error message is written  out it goes into  ~writeLnHook~ callback
(misused for ~{.explain.}~)  (hacked for ~compiles()~) and  was written out
to the stdout/stderr.

Of course you can't  have a proper error reporting in  the nim compiler, so
this hook was also misused to  the point of complete nonsense. Most notable
clusterfuck  where you  could spot  this little  shit is  implementation of
~{.explain.}~ pragma  for concepts. It  was implemented via  really 'smart'
(aka welcome to hell) solution in

[[https://github.com/nim-works/nimskull/commit/74a80988d9289e8147a791c4b0939d4287baaff3][74a8098]] (=sigmatch= ~704) and then further "improved" in [[https://github.com/nim-lang/Nim/commit/fe48dd1cbec500298f7edeb75f1d6fef8490346c][fe48dd1]] by slicing
out  parts  of  the  error  message with  ~let  msg  =  s.replace("Error:",
errorPrefix)~

*** Quality of the source code

**** Commit messages

Source code implementation has an absolutely appauling quality with unclear
commit  messages and  a very  interesting [[https://github.com/nim-lang/Nim/pull/19211][attitude]]  from some  of the  core
developers.

#+begin_quote
I have no intention to follow this guideline so I cannot accept it. The problem is real, but the solution is to write some simple tool that makes "git log" more useful.
#+end_quote

The PR  was merged at [2021-12-03  Fri], but it didn't  really prevent [[https://github.com/nim-lang/Nim/commit/07b645342abd06b2323df042c170eb847f51880d][more]]
[[https://github.com/nim-lang/Nim/commit/48d41ab375498ba638863b55807bac96eccf667a][fixes]],  [[https://github.com/nim-lang/Nim/commit/81087c949f620dc80697364da414872791ffe23c][fixes]], [[https://github.com/nim-lang/Nim/commit/81087c949f620dc80697364da414872791ffe23c][fixes]],  [[https://github.com/nim-lang/Nim/commit/08ae3467b9b3f52fa568bbf06a9057a87020158b][refactorings]],  [[https://github.com/nim-lang/Nim/commit/6d8178a93e14f24cbb327cf718de181942339126][closes]] etc.  But I  guess  it is  not
surprising given core contributors seem  to have an inverse proportion wrt.
to the number of commits and  their documentation, starting with =Araq= not
writing anything else beside a title (49 characters).

#+caption: Average commit message lenght
#+begin_src elvish
var file = "/tmp/count"
git log --pretty="format:%an;;;%s %b" | cat | rg "(Andreas Rumpf|Araq)" | sd "^.*?;;;" "" > $file
echo "Average commit: "(echo (wc -c < $file) "/" (wc -l < $file) | bc -l)", #commits "(wc -l < $file)
#+end_src

| Core contributor | average message length | number of commits | status   |
|------------------+------------------------+-------------------+----------|
| Araq             |                  48.59 |              8898 | active   |
| Dom96            |                  64.00 |              1477 | active   |
| Timothee Cour    |                     82 |              1088 | inactive |

**** Code quality itself

Before going into specific examples I want to briefly outline the situation
with  the data  flow  inside of  compiler  and what  types  are often  used
internally.

The most important type you should know about is ~PNode~ -- the name itself
is a pascal-era artifact and effectively  means "node". The type is used to
represent your  code inside of the  compiler -- all files  are first parsed
into ~PNode~ then sem modifies it and finally generates the target code for
various backends.  The whole compiler  pipeline uses the single  type, from
start to finish.

~PNode~ [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/ast.nim#L785][is]] a variant [[https://nim-lang.org/docs/manual.html#types-object-variants][object]] that uses [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/ast.nim#L36][TNodeKind]] as a switch type. Kinds are
divided  into two  broad categories  -- literals  (integer, floating-point,
string)  and 'container'  (definitions, statements,  expressions etc)  that
store nodes in a strictly ordered fashion.

****** Reliance on exception handling for control flow

TODO rewrite cleanly, link to the procedures in the source code.

The simplest example would be ~globalError()~ — it is a template defined in msgs.nim which raises ~ERecoverableError~ as a means of execution control. For example, if you have a static[int] argument in a function overloading resolution will try to evaluate the expression you used as an argument and raise exception on failure which ends up in the try ... except block somewhere. Now imagine trying to figure out the control flow logic of how two systems of the compiler interact with each other, multiply by ~100 instances of globalError() sprinkled all over the code and you get some understanding

and is not the only example, mind you, it is just one of dozens separate issues that are layered on top of each other

not using exceptions for control flow is a programming 101 if you ask me, but apparently it is not the common knowledge

let me pull the links in the implementation so you can see what I'm talking about, one second

https://github.com/nim-lang/Nim/blob/1707bc4a992bc966a7439facb9ee819023c22f77/compiler/sem.nim#L354-L362

this code is responsible for trying evaluation of the static[T] arguments

https://github.com/nim-lang/Nim/blob/0ead94c4eb8042bc6f8f313dd5ed4f05eb375330/compiler/vm.nim ctrl+F "globalError" -> 12 results

https://github.com/nim-lang/Nim/blob/a228e331f30def00d4369d4e792c7454963d8c4e/compiler/vmgen.nim + 23 more

each of these calls can end up in the tryConstExpr

so right here, you have 35 possible paths of how analysis of the expression can go wrong

***** Magical indices all over the code

Access to  the data in  the AST is  largely performed using  direct indexed
access --  there are over  four thousand naked ~[IDX]~  accesses throughout
the code  (~rg '\[\d+\]' |  wc -l~ => 4601  ATTOW). In order  to understand
what [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/semexprs.nim#L2498][some]]  [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/semstmts.nim#L1863-L1864][piece]] of  [[https://github.com/nim-lang/Nim/blob/69eaa4f14cdb1276650141adb6b2e96f478e0856/compiler/semstmts.nim#L1448-L1453][code]] might  be doing you  would need  to know  all the
possible node kinds that pass through this part of the code.

Explanation  for the  transformations that  are performed  on the  nodes is
largely absent.

***** Tens of thousands of one-character variables

Number  of  one-character  variables  in the  implementation  is  downright
obscene. There  are some common  cases like  ~g~ or ~ModuleGraph~,  ~c~ for
~PContext~,  ~TContext~  or  ~PPassContext~,  ~m~  for  ~Module~,  ~n~  for
~PNode~, but overall number of the  one-char variable usages goes into tens
of thousands (~rg -g "*.nim"  '[\s(.\[][a-z][\s)=.:\[\]]' | wc -l~ => 33834
ATTOW) sometimes concentrating in an absolutely unimaginable numbers:

#+begin_quote
one-char [[https://github.com/nim-lang/Nim/blob/f540fd5cde268d2ecd1e22a20cac0879bf405f85/compiler/passes.nim#L121-L124][variables]]  followed by two  nested loops that introduce  [[https://github.com/nim-lang/Nim/blob/f540fd5cde268d2ecd1e22a20cac0879bf405f85/compiler/passes.nim#L155][more]] than
[[https://github.com/nim-lang/Nim/blob/f540fd5cde268d2ecd1e22a20cac0879bf405f85/compiler/passes.nim#L177][shadow]] them. This  part of the compiler serves as  a main semantic analysis
entry point  if I'm  not mistaken -  I'm writing this  while I'm  trying to
decipher its purpose, so I might be a big wrong.
#+end_quote


#+begin_quote
[[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2209][sigmatch.paramTypesMatch]] has a total of *NINE* one-character variables - [[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2209][m]],
[[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2209][f]],  [[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2209][a]], [[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2220][x]],  [[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2221][y]], [[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2222][z]],  [[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2218][c]], [[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2237][r]],  [[https://github.com/nim-lang/Nim/blob/cde6b2aab8f67291eca5375a067f97e98b7593ee/compiler/sigmatch.nim#L2227][i]], all  involved in  a complex  algorithm of  best
candidate argument  search - that's about  a third of an  english alphabet.
Good to know the algorithm complexity  has such robust limiting mechanism -
at most you can write code that is three times as complex, not more.
#+end_quote

***** Sea of 'convenience' templates

Large  number of  'convenience' templates  that  (1) do  not specify  their
argument  types, (2)  implicitly  capture something  (or  expect) from  the
environment .  Examples include both [[https://github.com/nim-lang/Nim/blob/8dcf367e5223ae26b57c9bbfaec6e70ac14bb820/compiler/lexer.nim#L258][tokenEnd]],  [[https://github.com/nim-lang/Nim/blob/8dcf367e5223ae26b57c9bbfaec6e70ac14bb820/compiler/lexer.nim#L283][eatChar]], [[https://github.com/nim-lang/Nim/blob/8dcf367e5223ae26b57c9bbfaec6e70ac14bb820/compiler/lexer.nim#L269][tokenEndPrevious]] -
which are not  so bad, and [[https://github.com/nim-lang/Nim/blob/8dcf367e5223ae26b57c9bbfaec6e70ac14bb820/compiler/vm.nim#L78][vm.stackTrace]] which  injects ~return~, obscuring
the control flow each time it is used in the code.

TODO astrepr implementation with ~compiles~ hacks

***** Exceptions for control flow

~globalError~ and ~ERecoverableError~ for control flow handling - there are
around  *one hundred*  (105  ATTOW)  calls to  the  ~globalError~ that  can
arbitrarily raise "recoverable" exception during semantic analysis which is
then   caught  in   the   ~semexpr~  and   discarded  (~tryExpr~,   ~except
ERecoverableError: discard~) and [[https://github.com/nim-lang/Nim/blob/b6bfe38ff5283f77d5e5e78da06d2710bc16afb6/compiler/sem.nim#L361][some]] [[https://github.com/nim-lang/Nim/blob/b6bfe38ff5283f77d5e5e78da06d2710bc16afb6/compiler/sem.nim#L662][more]] [[https://github.com/nim-lang/Nim/blob/d4c0d35b32e51eae06e65e78c253cdaf8bb42446/compiler/suggest.nim#L614][examples]] of [[https://github.com/nim-lang/Nim/blob/0014b9c48e883d3c04995b9e83bb0f8468a16df6/compiler/semexprs.nim#L2204][this]].

Exceptions being used  for control, discarding exceptions  - again, someone
(like me)  might consider this  to be a  bad code smell  that significantly
reduces the readability. Whole codebase turns into spaghetti.

*** Extra

- Linux [[https://github.com/nim-lang/RFCs/issues/58#issuecomment-442785793][is]] "fundamentally broken" and

  #+begin_quote
  dlopen  is widely  used by  Python, Ruby,  Perl, ...  what you're  really
  telling me  here is that your  OS is fundamentally broken.  That might be
  news for you, but it isn't for me.
  #+end_quote

  So using  native linker is  not a feasible option  -- proven by  the fact
  *dynamic* languages (TIL  Nim is a [[https://github.com/nim-lang/Nim/issues/9203#issuecomment-428201355][dynamic]] language,  right) use ~dlopen~
  so instead  it would be better  to just [[https://github.com/nim-lang/Nim/blob/1247043c9036fb6029c87bf5bed9021c6eff6092/lib/wrappers/openssl.nim#L337-L357][reimplement]] random  pieces of the
  linker and still resort to low-level [[https://github.com/nim-lang/Nim/blob/1247043c9036fb6029c87bf5bed9021c6eff6092/lib/wrappers/openssl.nim#L411][hacks]].

*** C++ backend

C and  C++ backends  are needlessly  different when  it comes  to derived
object handling and [[https://github.com/nim-lang/Nim/blob/de89f6ce3233751a5c364100b902eadfc27086a4/compiler/ccgtypes.nim#L708][preference]] of ~&~ references.

- When  the  *C*   backend  uses  [[https://github.com/nim-lang/Nim/blob/de89f6ce3233751a5c364100b902eadfc27086a4/compiler/ccgtypes.nim#L602][inheritance]]  it  is   done  via  object
  [[https://github.com/nim-lang/Nim/blob/de89f6ce3233751a5c364100b902eadfc27086a4/compiler/ccgtypes.nim#L615][composition]], but when a project is compiled via the *C++* backend it is
  done using native inheritance instead.
- This   leads   two   different   modes  of   handling   parent   fields
  ~obj.Sup.field~ vs ~obj.field~
- Different argument passing - on C++ backend native references are used,
  further  exacerbating the  issue and  leading to  codegen bugs  such as
  ~**&~ being generated
- Different handling of the derived object slicing - ~var Base~ is called
  with ~&derived.Sup~  on the *C* backend  and as ~derived~ on  the *C++*
  backend. Latter is made possible due to the ~&~ reference.

  #+begin_src nim
type
  Base = object of RootObj
    field1: int

  Derived = object of Base
    field2: int

proc passBase(base: var Base) =
  echo base.field1

var der: Derived
passBase(der)
  #+end_src

  For "not a  transpiler" compiler nim certainly tries  to translate into
  too many high-level C++ constructs.

These  differences  are  supposedly   orchestrated  from  withing  semantic
[[https://github.com/nim-lang/Nim/blob/de89f6ce3233751a5c364100b902eadfc27086a4/compiler/semexprs.nim#L719][analysis]]   for  expression   processing  which   creates  backward-pointing
information link  during compilation.  Macros get different  AST structure,
code generation  can work out  two varying code structures,  later compiler
stages need to anticipate AST variations.

** TODO Tooling implementation issues

[[https://github.com/nim-lang/RFCs/issues/300][Developer    tooling   ·    Issue   #300]]    ([[https://web.archive.org/web/20221024162725/https://github.com/nim-lang/RFCs/issues/300][archive]])   is    second   most
commented-on[fn:on-96] and third most-upwoted issue currently open issue in
the repository.  At the time of  writing [2022-10-24 Mon] it  has been open
for almost two  years -- added to  the 2021 milestone, then  described as a
/"the most important thing for me personally"/ thing in the [[https://github.com/nim-lang/RFCs/issues/437][roadmap]].

[fn:on-96] Second only to a [[https://github.com/nim-lang/RFCs/issues/456][Nim v2: get rid of style insensitivity · Issue
#456]] aka
#+begin_quote
Not because  style insensitivity leads to  bugs or any of  the other things
that those  unfamiliar with Nim  hypothesise but because  it is one  of the
main reasons that people do not even try Nim
#+end_quote
which gathered  a whopping 220  responses over  a topic that  is completely
dwarfed in importance  by the working developer tooling.  This question had
been raised four years ago as well on the nim forum [[https://forum.nim-lang.org/t/4388][Should we get rid of
style insensitivity?]] with no concrete results.

** TODO Project priorities and goal-setting

*** General project roadmap

[[https://github.com/nim-lang/RFCs/issues/437][Roadmap for  Nim ·  Issue #437]] had  been created only  after long  and ugly
[[https://forum.nim-lang.org/t/8627][discussion]] where core project developer apparently [[#= ][learned]] that

#+begin_quote
    It's good that I have a plan.
    Even better would be if I shared it with the community...
#+end_quote

Too bad the roadmap still did not include the, well, *road* component of it
-- specifically  how to  get to  the  point listed,  so  it was  more of  a
wish-list than a real roadmap. But that's something at least, and you would
be hard-pressed to  find /anything even resembling it/ for  the most of the
core project existence since 1.0.

*** Managing specific projects

**** ~c2nim~ automatic wrapper generator

Nim interop a *big*  topic when someone starts using nim,  but it there has
never been  any official effort aside  from a *[[https://forum.nim-lang.org/t/8020][handwritten]]* C++  parser (if
you have any  knowledge of the subject  you should run away  already) and a
tool that requires you to [[https://github.com/nim-lang/c2nim/blob/master/doc/c2nim.rst#def-directive][modify]] the headers.

Aside from  questionable UX this project  itself has no direct  issues with
management.

**** standard library

There are no clear guidelines or  rules on how packages in standard library
need  to be  updated,  deprecated  or improved.  Some  of  them have  known
long-standing performance or usability issues (TODO link json, tables, what
else there is? TODO scour logs for in-depth discussions).

------

- [[https://forum.nim-lang.org/t/9627][Procedure to remove modules from stdlib?]] -- a nim forum thread
- [[https://github.com/nim-lang/RFCs/issues/473][Candidates for separation from standard library · Issue #473 ·
  nim-lang/RFCs · GitHub]]



**** Nim forum

- [[https://github.com/nim-lang/nimforum/issues/180][searching posts by user should not be limited to 1st 10 posts/threads ·
  Issue #180 · nim-lang/nimforum ]]
- https://www.reddit.com/r/nim/comments/7smw81/comment/dt7xmab/
- https://forum.nim-lang.org/t/3534#22078
- https://forum.nim-lang.org/t/8852#57838

**** fusion

I  was  involved  in this  part  personally,  so  I'm  going to  provide  a
first-hand account in this specifically  I worked on the "official" pattern
matching implementation solution.

Back in 2020 ~@alehander92~ (author of  the Gara [[https://github.com/alehander92/gara/][library]], nil [[https://github.com/nim-lang/Nim/pull/15287][check]] feature
and many  [[https://github.com/nim-lang/Nim/pulls?q=is%3Apr+sort%3Aupdated-desc+author%3Aalehander92][other]] PRs) wrote  an [[https://github.com/nim-lang/RFCs/issues/245][RFC]]  about pattern matching.  Several months
later I  [[https://github.com/nim-lang/RFCs/issues/245#issuecomment-695780794][joined]] the discussion,  providing a starting [[https://github.com/haxscramper/hmisc/blob/f58838040170547e19c01bd6b9f3e42a16811f91/tests/tMatching.nim][implementation]]  and a
specification  that later  was [[https://github.com/nim-lang/RFCs/issues/245#issuecomment-697897542][expanded]]  and agreed  upon. At  this time  I
[[https://github.com/nim-lang/RFCs/issues/194#issuecomment-700994731][thought]] it should be a move  to consolidate the ecosystem. I [[https://github.com/nim-lang/fusion/pull/33][implemented]] it
for the fusion library  and it was merged after an  initial review.

At this point I thought that people can finally make use of it in different
scenarios, simplify writing macros and so on, writing my [[https://github.com/nim-lang/website/pull/252][first]] iteration of
the article. About  two weeks later fusion was [[https://github.com/nim-lang/Nim/pull/16925][unbundled]]  from the standard
library and  left on it's own  as a separate  package with an idea  it will
also [[https://github.com/nim-lang/fusion/issues/30][adopt]] semantic versioning (never really  happened). Then I had to wait
for over a month until by patience finally [[https://github.com/nim-lang/website/pull/252#issuecomment-786700979][ran out]] and I decided to publish
it  myself somehow.  Eventually it  was [[https://github.com/nim-lang/website/pull/271][published]],  received 145  points on
[[https://news.ycombinator.com/item?id=26420716][hackernews]]. In March someone made a video tutorial on the [[https://www.youtube.com/watch?v=GJpn6SfR_1M][library]].


Fast forward to 1.6.0: new  version introduced the ~nnkTupleConstr~ - which
required some fixing, which was promptly done by ~@clybber~ ([[https://github.com/nim-lang/fusion/pull/86][PR]]). So far so
good. Except  after unbundling never  received any proper tags,  and people
still [[https://github.com/nim-lang/fusion/issues/99][get]] [[https://www.reddit.com/r/nim/comments/qfi1d0/fusionmatching_broken_in_nim_16/][version]] that  is nine months old. I wasn't  really privy into the
management details, assuming  the official library tagging  would have some
work done on it, and simply worked on the [[https://github.com/nim-lang/fusion/pull/94][PR]] with additional fixes.

My PR had  a CI failing for  a five months purely  due to [[https://github.com/nim-lang/fusion/pull/100][misconfiguration]],
and I  had to personally  come and complain about  it in order  for leorize
(another  person who  moved  to  nimskull btw)  to  fix  it --  effectively
confirming that  not a single  maintainer bothered  to look through  PRs in
fusion for almost half a year.

After fixing CI -- Half a month forward, zero reaction. Is fusion a part of
the current  nim effort, or is  it not - I  don't know. Each time  it was a
waiting game, or I had to personally come and push people around so someone
even looked at my efforts, maybe even reviewed the code. No, five months of
silence with  dead CI,  no understanding  if my work  is even  needed, then
another half a month with fully green CI, and still no reaction.

Then "Preview of the coming attractions"  [[https://forum.nim-lang.org/t/8627][thread]] happened. I made the point
[[https://forum.nim-lang.org/t/8627#56155][above]] and learned that

1. there were no reviews for fusion because Araq didn't get emails (/"it's
  however badly  maintained as I get  no emails from github  when there is
  activity"/) -- it looks like not a  single person from the core team had
  ever looked at the repository.
2. The proper solution is to give me more permissions so I could just merge
   stuff in without  reviewing -- not figuring out why  official library is
   just completely neglected.


Almost two weeks later after this thread, fusion still wasn't tagged tagged
(surely it  was hard  to do),  released roadmap does  not even  mention it[fn:it-618],
nimble is briefly  described as /"We hope  to be able to ship  a new Nimble
with the  2.0 release but  we are happy to  ship it whenever  it's ready."/
(probably  my [[https://github.com/nim-lang/RFCs/issues/437][RFC]]  is  either implied  as  "you should  know  about it"  or
something like  that, definition  of ready  is not  provided, no  idea what
state is it in now[fn:now-623])

------

Last [[https://github.com/nim-lang/RFCs/issues/476][discussion]] about  fusion talked of its deprecation.  The next reviewed
[[https://github.com/nim-lang/fusion/pull/16][PR]] took about a year until it was noticed.

[fn:now-623] See [[id:fbd820bb-9a38-4eba-ad53-8f75e018aea5][nimble package manager]] section for more details, but tl;dr
is: it after about a year it is no  more ready than it was back then and my
RFC still remains the only piece  of strategic planning that have ever been
proposed.

[fn:it-618]  The  edit was  added  on  [2021-12-01  Wed]  -- only  after  I
mentioned it on the forum.

**** ~nimble~ package manager
     :PROPERTIES:
     :ID:       fbd820bb-9a38-4eba-ad53-8f75e018aea5
     :END:
     :LOGBOOK:
     - Refiled on [2022-11-18 Fri 13:29:01] from [[id:29e7b85f-c637-4f8a-b9a6-c594f9fe833d][nimskull-notes:Part one: "why"]]
     :END:


On July 4th, 2021 I wrote  the [[https://github.com/nim-lang/RFCs/issues/398][RFC]] detailing various issues and suggestions
for the package management improvements that provided a detailed account of
most of the things that were wrong with the package manager at the time.

***** UX and implementation issues

***** Non-existent level of interest in package manager improvements

1. Non-existent dependency  resolution algorithm that can  get knocked over
   at any time, causing bugs and repeated installations.
2. Bidirectional data  flow between the compiler and package  manager -- it
   is not  possible to  run the  compiler separately with  the same  set of
   packages as in command-line.

- There [[https://forum.nim-lang.org/t/8147][were]]  (thread [[https://archive.is/vqBcG][archive]])[fn:archive-846] [[https://github.com/bung87/slim][several]]  alternative package
  managers that tried  to solve various issues over the  years. Thread also
  has some important sentiments about state of the ecosystem in general

  #+begin_quote

  #+end_quote


[fn:archive-846] Discord [[https://discord.com/channels/371759389889003530/753721959308853319/843776451693903884][link]] for message mentioned by =Clonkk=

***** Dead community management

****** No strategic roadmap for a long time

[[https://forum.nim-lang.org/t/8147#52417][Sentiment]] from Jun 2021

****** Two-year-old version is shipped

Nimble package  manager is  shipped with default  =choosenim= installation.
Specific  version of  the package  is hardcoded  in the  ~koch.nim~ builder
using   git  [[https://github.com/nim-lang/Nim/blob/73680cef953bd9c42b7c7c4e8081d0ae609de772/koch.nim#L13][hash]]   and   currently   points  to   the   [[https://github.com/nim-lang/nimble/commit/d13f3b8ce288b4dc8c34c219a4e050aaeaf43fc9][version]]  that   is
[2021-02-19 Fri]--[2022-11-13 Sun] => 632 days old.

If you look into git [[https://github.com/nim-lang/Nim/commit/3d7c52f3cd6c08a175a8e8f8ed79757dd027648f][blame]] you can see a very interesting commit message

------
#+begin_quote
[backport] Revert "use new Nimble, with lockfiles ([[https://github.com/nim-lang/Nim/pull/18810][#18810]])" ([[https://github.com/nim-lang/Nim/pull/18872][#18872]])

This reverts commit [[https://github.com/nim-lang/Nim/commit/f373c17ad926b669bb3b5819ae1dff4bde1da88a][f373c17]].

For more details, see:
- [[https://github.com/nim-lang/nimble/issues/940][nim-lang/nimble#940]]
- [[https://github.com/nim-lang/Nim/issues/18840][#18840]]
- https://forum.nim-lang.org/t/8404
#+end_quote
-------

Reverted    [[https://github.com/nim-lang/nimble/commit/795704833ddfd0cdaefb45c60551d3ea205279ef][commit]]   actually    points   to    a   much    newer   version
([2021-09-03 Fri]--[2022-11-13] =>  436 days). The reason  for reversal can
be seen in detail in the linked  [[https://forum.nim-lang.org/t/8404][thread]], but tl;dr version: ~v0.14~ broke a
lot of  people's workflows  and didn't  provide any  reasonable alternative
that people would be satisfied with.  Almost all changes in v0.14 come from
the gigantic [[https://github.com/nim-lang/nimble/pull/913][PR]] (+9,187/−2,887)  that originally targeted implementation of
the  [[https://github.com/nim-lang/nimble/issues/127][lockfiles]] according  to the  [[https://github.com/nim-lang/nimble/issues/127#issuecomment-455612545][specification]] but  later grew  to require
compiler  [[https://github.com/nim-lang/Nim/pull/12104][modifications]]  (bidirectional  dependency  between  compiler  and
package manager) and include

1) Parallel package download
2) Intermediate package.nim.cfg file
3) Lock files
4) Changes to  the nimble  develop command  -- change  that caused  the most
   issues.
5) Changes to nimble check

The documentation  wasn't especially  clear as  not a  lot of  people could
figure  out  that  some  original  features  could  actually  be  emulated,
according to the [[https://forum.nim-lang.org/t/8404#54497][comment]] from one of the core developers (which I [[https://github.com/nim-lang/nimble/pull/943#issuecomment-922681649][suggested]]
adding to the documentation, but I guess I wasn't persuasive enough).

Several months  later Nimble  came up  in the discussion  again, in  a very
interesting  [[https://irclogs.nim-lang.org/03-11-2021.html#11:44:14][context]]: "development  has been  outsourced, wasn't  ready for
1.6.0 and I don't know the plan either" (Remember -- this is a core project
contributor talking about the central piece of the ecosystem)

------------------

Attempted  fixes also  included [[https://github.com/nim-lang/Nim/commit/908fc2a22e7336670173bcd06ab30f440ca6d321][addition]]  of the  ~pkgs2~ directory  to the
nimble path.

# #+begin_quote
# By  the  way,   speaking  of  roadmap  and  project   [[https://irclogs.nim-lang.org/03-11-2021.html#11:44:14][management]]  -  nimble
# [fn:either-96] -- this happened moths after long discussion
# about  added nimble  features, subsequent  reversal  of the  version to  be
# release https://forum.nim-lang.org/t/8404#54511 and we still don't have any
# concrete roadmap about plans to roll out 14.0.

# So these are my two cents on how having a good roadmap could've prevented a
# almost  a year's  worth  of  effort (pattern  matching)  to  not lose  it's
# maintainer, and how you managed to loose a single person who was interested
# enough to really  try to compose the plans,  suggestions, improvement ideas
# and  vision for  the  package  manager into  something  coherent, not  "the
# discussions were  spread through  multiple Github  issues, IRC  and private
# chats with the Nim team on Telegram" [[https://discord.com/channels/371759389889003530/753721959308853319/892742985626824734][discord link]].

# This is my personal view of the matter, I'm not going to lie and say that I don't care anymore, but I'm certainly burned out by this indifference and uncertainty to the point I no longer want to do anything unless explicitly asked for - and this certainly would not include "please continue to maintain pattern matching"

# P.S. you can consider it my resignation letter from the fusion/matching maintainer. I wanted it come to become a standard, but well, not like I can continue to work on it if the fusion itself is dead.
# #+end_quote

** TODO Ecosystem and community health

*** TODO Repository issues

**** TODO Number of issues in the repository over time

**** TODO Average time to close the issue

*** TODO Repository pull requests

**** TODO Number of pull requests merged per day

**** TODO Percentage of the pull requests rejected/merged/stalled

# NOTE certain people will have different  rates of closing and opening the
# pull requests. I need  to know how many PRs did  Araq merge from himself,
# how many did he merge from dom96 and so on.

*** TODO Number of commits per period of time

# IMPLEMENT  split  number  of  interactions  with  certain  parts  of  the
# repository -- for example, commits that only touch a standard library are
# not especially interesting and can be ignored.

*** TODO Engagement of the core contributors in the repository

**** TODO Number of comments on various issues

**** TODO Number of commits

** TODO Financing and team management

Yes, money  talk. Although  I can't say  there is a  single instance  I can
remember that  can even be  characterize as  even /sketchy/, but  there are
more than a few loose ends I personally understand.

- Status  allegedly  finances nim  development,  but  I've never  seen  any
  official account  for this and judging  from some [[https://discord.com/channels/371759389889003530/371759607934353448/973912902903951382][remarks]] ("And  then how
  Status pays Araq  money is something for  him to explain if  he wishes, I
  know some  details but don't  want to make it  public in case  he doesn't
  want to.") it is not considered important enough to be discussed.
- Nim has [[https://nim-lang.org/blog/2021/10/25/nim-receives-100k-usd-bitcoin.html][received]] 100k in bitcoin  donations that then were transferred to
  this  [[https://www.blockchain.com/btc/address/1BXfuKM2uvoD6mbx4g5xM3eQhLzkCK77tJ][address]] and  subsequently split  into  [[https://www.blockchain.com/btc/address/bc1qzgw3vsppsa9gu53qyecyu063jfajmjpye3r2h4][these]] [[https://www.blockchain.com/btc/address/bc1qde22ua57hqvl36657mkx4x2gvwp5gn5xh34g6f][two]],  where the  money
  reside up to  this day. I've never  heard about any plans  to do anything
  with these  money, but  the USD value  had dropped by  a factor  of three
  since then.
- It is not really clear who actually works on the project full-time and is
  paid  core contributor,  who  is  just a  volunteer  and  who is  getting
  periodically [[https://opencollective.com/nim/expenses/97898][paid]] to work on a  specific [[https://github.com/nim-lang/RFCs/issues/437#issue-1058638395][tasks]] (most checkpoints had been
  closed by the ~@xflywind~).

** TODO Community moderation, code of conduct
   :LOGBOOK:
   - State "TODO"       from              [2022-11-18 Fri 13:33:32]
   :END:

# TODO Cabbose ban "keeping the flames burning"

According to Araq the Code of Conduct is a waste of [[https://forum.nim-lang.org/t/2332#14329][time]] (thread [[https://archive.ph/veV0I][archived]]).

#+begin_quote
Because it's a  waste of time[fn:C-810]. The recent  troll attacks wouldn't
have been  prevented by a  CoC[fn:C-810]. CoCs are  naive[fn:naive-811] and
actually  can start  all sort  of fights  over the  precise[fn:precise-813]
wording etc. I can already envision this  very thread to become a page long
discussion[fn:discussion-813] with  people arguing about the  pros and cons
about CoCs.  I would lock[fn:lock-815] this  thread if I could  (maybe I'll
patch nimforum) to save everybody's time ("safety first"). Please! -- Araq
#+end_quote

There  are  some  internal  moderation  [[https://forum.nim-lang.org/t/8629][guidelines]]  that  have  never  been
[[https://irclogs.nim-lang.org/18-11-2022.html#09:34:53][published]] ([[https://archive.is/YIpVo#09:34:53][archive]]) after all this time.  The best resource is a forum [[https://forum.nim-lang.org/t/9138#59679][post]]
-- why not put it in as an official guideline is beyond me.


After  fifteen  years  of  nim's  existence  many  people  had  joined  the
community, attempting to contribute to  the language and greater ecosystem,
but  eventually moved  away because  of  the negligence  of their  efforts,
inflexible attitude towards technical details.

- [[https://nitter.snopyta.org/d0m96/status/1592827547582332929][dom96]] (package manager, async implementation)
  #+begin_quote
  I've been  moving away from Nim  for a while  now, and sadly this  is the
  reason why.  I want  to be  a part  of a  community that's  inclusive and
  welcoming. Just to be clear, Araq is completely wrong, and these kinds of
  statements have hurt the Nim community in the past.
  #+end_quote

  twitter  [[https://twitter.com/d0m96/status/1592827547582332929][link]],  dlang  thread   [[https://forum.dlang.org/post/wzoecavcswedkiebcjft@forum.dlang.org][live]],  archived,  reddit  [[https://old.reddit.com/r/nim/comments/ywxsbz/this_is_disappointing_to_read_coming_from_the_nim/][discussion]]  (75
  comments, apparently most [[https://old.reddit.com/search?q=subreddit%3Anim&restrict_sr=&sort=comments&t=all][commented]] thread on the forum), [[https://old.reddit.com/search?q=subreddit%3Anim&restrict_sr=&sort=comments&t=all][archived]]). Araq
  [[https://www.google.com/search?q=site:https://forum.dlang.org+Araq][actually]]  [[https://forum.dlang.org/post/lhhxvlxfddxnreyfhbct@forum.dlang.org][frequents]]  [[https://forum.dlang.org/post/ljlapidqpiyafzclbreo@forum.dlang.org][dlang]]  forum,  although  most of  it  is  usually  a
  technical discussion.
- leorize (vim plugin) -- moved to nimskull
- saem (VSCode plugin) -- moved to nimskull
- disruptek (CPS  implementation, alternative package manager)  -- moved to
  nimskull
- gradha
- lemonboy
- StephanSalewski
- timotheecour
- clyybber
- krux02


[fn:C-810] Yes, code of conduct does not provide a universal troll defense,
it just  documents that people  have actually agreed  to be a  decent human
beings towards each other -- of course trolls don't agree with this.

[fn:naive-811] Yes, code  of conduct is a rather loose  document, not meant
to be used a rigid prosecution tool.

[fn:discussion-813] Yes, if core teams explicitly refuses to write down any
laws there is going to be anarchy, thread derailing, spam, trolling and god
knows what.

[fn:lock-815]   But the  solution is  not  to force  your perspective  onto
everything, but to either moderate  the discussion or actually consider how
much alleged "damage" code of conduct "can" inflict.

[fn:precise-813] We've been  running the project with [[https://github.com/nim-works/nimskull/blob/devel/CODE_OF_CONDUCT.md][CoC]] for  about a year
now and so far we haven't been  drowned in the endless debate over specific
wording. If you don't treat the  community guidelines as blunt weapons that
either work or don't then it becomes a lot easier to accept.

* Part two: "nimskull"

There is no point denying that the project had started as a fork of the nim
programming language  compiler, but at  the same time  it is less  and less
relevant as time goes  on, because we want to move into  the direction of a
/better language/ not a /better reimplementation of a nim compiler/.

A  specific meaning  of  this  distinction will  be  provided  in the  next
section, here I will briefly talk  about some of the common misconceptions.
After this  article is  written I  will try  to update  the readme  text to
reflect the list.

* Part three: our deal

This  is  specifically  aimed  to provide  the  explanation  about  working
procedures in  the project,  explain the  value framework  that is  used to
decide what  is going to  be worked  on and what  is going to  be postponed
until a later date.

I  decided it  would be  better  to formulate  my  ideas on  this topic  as
precisely as I can, even if it might  sound harsher than it needs to be. It
probably will  never end up  in the official  readme, because that  sort of
wording and language is very unlikely to excite new contributors and users.

The most important notion that should be understood is that each project is
working off a  finite resource -- a  limited number of people,  who have an
finite amount of time they can dedicate. They don't want to have a /burnout
on the OSS/ projects and they want  to /work on the stuff they enjoy/.

At this  moment in  the goals  of the  project are  almost entirely  set by
contributor team  (as opposed to  being driven by external  requests). Said
team  decided that  it would  be the  best  user of  their time  to (in  no
specific order):

1. *DO  NOT* provide a LTS  version that keeps backward  compatibility with
   mainline nim.
2. *DO  NOT* /try/  to keep  the backwards  compatibility in  the following
   cases (and similar scenarios):
   1. If better language design emerges.
   2. If the feature had already been marked as deprecated in the mainline
   3. If the feature is implemented in form of opt-in language dialect
   4. If keeping the feature intact will require significant compromises on
      the code quality and maintainability.
3. *DO  NOT* hesitate  to make  a hard decisions  if it  would allow  for a
   large-scale cleanup to move forward.
4. *DO  NOT* spec  out bugs and  *DO NOT* solidify  bugs into  the language
   design.
5. *DO* work on the internal documentation, development history
6. *DO* work that improves the internal architecture of the compiler.
7. *DO* reduce the barrier of entry to the new contributors
8. *DO*   prioritize  the  consistent  language   design  over  occasional
  convenience.
9. *DO*  work on consolidating  existing language dialects into  a /single/
   language, not exponential number of possible flag combinations.
10. *DO* work  on specifying  exact  rules of  the aforementioned  /single/
   language.

Having read that a user can  decide for themselves whether *they think* the
trade-offs are acceptable  *for them*.

Personally, I  think it is important  to honestly set the  expectations and
adhere  to the  community  contract  you proposed,  rather  than trying  to
accommodate for every  single user from the old community.  Yes, that might
sound overly harsh, but  I don't want to move along  the =vlang= route with
over-promises and under-deliveries.

Three important  points that should  be emphasized  in regards as  to where
this list is relevant and where it is not:

1. The  list above explains the  principles under which we  operate when it
   comes to the decisions related  to the *implementation* and weighing out
   the  pros  and  cons  of  technical  decision.  Discussion  process  and
   community handling  are regulated  by the  Code of  Conduct and  Code of
   Ethics which take priority over all interactions.
2. The list should serve as a  breakdown of the developer team priority and
   served as  a first filter  that is used  to consider specific  ideas and
   requests.
3. It explicitly does not provide breakdown of a specific new feature-based
   objectives  in this  section. Current  part of  the work  is focused  on
   solving implementation issues with already existing features.

* Part four: our vision

#+begin_center
[[./nimskull_roadmap.drawio.pdf]]
#+end_center

Roadmap   provides  a   high-level   overview  of   the  project's   goals.
Implementation details can be seen in the next section: "our scopes".

- Add structured diagnostic [1] ::  Rewrite diagnostic handling pipeline in
  the compiler internals.
- Testament improvements [2] :: TODO
- Separate parsed and mutated AST [3] ::
- First-class VM [4] ::
- Mid-level IR [5] ::
- Test as specification [6] ::
- Precise AST structure [7] :: ([[id:3747c453-d22f-41de-b0b3-9f2c8fbe32d9][scopes]])
- C backend rewrite [8] ::
- Automatic wrapper generator [9] :: ([[id:71e3dd81-5fd0-43b4-871f-9dbad57571e4][scopes]])
- Clean up and organize existing tests [10] ::
- Untangle Backend and Sem data [11] ::
- Dod for the while compiler [12] ::
- C++ /integration/ [13] :: ([[id:b5a161a8-9ea3-434b-87c6-451de4208ddc][scopes]])
- Code formatting [14] :: ([[id:06f149af-0064-4176-aef6-1668e276afa4][scopes]])
- Package manager [16] :: ([[id:718bfd67-5f93-4b54-89f4-32ff864b79fb][scopes]])
- Documentation generator [17] ::
- IC - incremental compilation [18] ::
- LSP [19] ::
- Fast recompilatoin [20] ::
- VSCode extension [21] ::
- CPS - continuation passing style [22] ::
- Build system [23] ::
- Layered approach to bundling [24] :: ([[id:274807cd-8a54-46c4-97ec-babc2959eec8][scopes]])
- Native pattern matching [25] ::



#  https://www.google.com/search?q=best%20effort%20principle
# https://www.investopedia.com/terms/b/bestefforts.asp#:~:text=The%20term%20best%20efforts%20refers,their%20securities%20offering%20as%20possible.
# https://www.google.com/search?q=work%20ethics%20conduct
# https://www.google.com/search?q=code%20of%20work%20ethics
# https://www.google.com/search?q=professional%20ethics
# https://www.google.com/search?q=scope%20of%20project
# https://www.google.com/search?q=vision%20of%20the%20project
# https://teamhood.com/project-management/project-vision-statement-make-sure-it-works/
# https://www.google.com/search?q=reasonable%20effort

In this  section I will  briefly outline a  general vision for  the project
moving forward. After more than a year of work it is a good idea to draw on
the newly discovered knowledge to help better define the direction.

This section does  not focus on the specific technical  details -- they are
provided in section five, "our scopes".

TODO cleanup

~>>>>>>>>>>>>>~

One of the most important goal is to make it easier for contributors on all
levels. Writing documentation and reorganizing the code is pretty good, but
there are lots of smaller things that improve quality of life. Attention to
details is important. You can continue  to keep the whole compiler codebase
in  one   folder  with  150+  files   or  you  can  separate   things  into
subdirectories based  on the respective  compiler subsystems. You  can keep
test suite as  a gigantic mess of ~t10489_a.nim~ files  that can be decoded
only if you  use git blame extensively  ... or you can spend  a fraction of
implementation efforts and  document what you've done and why  it should be
tested this  way. You can  keep adding various ~stdlib_misc~  tests, random
toplevel folders with a single test (TODO insert ~test.c~ link, link to the
gigantic ~stdlib~), misplaced tests (TODO insert ~collections~ link, stdlib
link), continue testing with ~echo~

https://github.com/nim-lang/Nim/tree/3469f37a56c31623eff473c65fd231bb5a77d5d8/tests/misc

~<<<<<<<<<<<<<~

** Layered approach to language design

TODO  elaborate,  tl;dr:  start  with  core spec  and  compiler,  then  add
libraries on top, tools and so on. Things that don't have to be in the core
repo  can be  placed somewhere  else, other  packages so  things don't  rot
alive.

** Interaction

* Part five: our scopes

In this section  I will provide a more technical  explanation about current
stage of the development, how it correlates with a vision from the previous
section ("our vision") and issues in the implementation "why".

This section  is mostly in line  with the near-term development  [[https://github.com/nim-works/nimskull#near-term-development][roadmap]] in
the  readme,  but  provides  a  lot more  historical  elaborations  on  the
implementation details.  I try  to keep  the most  relevant details  of the
reimplementation progress updated in the [[https://github.com/nim-works/nimskull/discussions/142?sort=new][thread]].

** TODO Precise AST structure :project##target:
   :PROPERTIES:
   :ID:       3747c453-d22f-41de-b0b3-9f2c8fbe32d9
   :END:
*** TODO definition of done :project##dod:
** Proper intermediate representation for compiler stages :project##target:

*** Data-oriented design

*** Lexer data

*** Parser data

*** Error data

Mainline  implementation  of  the  compiler  handling  does  not  have  any
structured  form  of  the  error message.  Things  are  randomly  formatted
in-placed using multiple of variations of different

*** Semantic analysis data

*** Embedded virtual machine data

*** Backend data

** TODO Incremental compilation :project##target:
*** TODO Definition of done :project##dod:
** Removing language dialects

Mainline has  a large number of  language dialects that affect  how code is
compiled  and what  features  are  available which  can  cause issues  when
enabled. Having  separate language dialects causes  combinatorial explosion
in testing  (~on/off~ test for each  flag, sometimes there are  more values
that  can be  allowed)  and some  things are  inevitably  fall through  the
cracks.

All  experimental  features should  either  be  implemented completely  and
enabled by default (such as "strict  funcs", "not nil" checking) or removed
from  the  implementation.  Optimizing  for  "what  if"  use  case  is  not
sustainable in the long run as  it disperses the efforts and requires large
amount of time to coordinate different parts of the language.

** Structured C and C++ interop :project##target:
   :PROPERTIES:
   :ID:       b5a161a8-9ea3-434b-87c6-451de4208ddc
   :END:

Right now  C and C++ interop  largely relies on the  fact backend generates
code listings and not binaries. This  makes it possible to have things such
as  ~{.emit.}~ and  various ~importcpp~  patterns. Compiler  does not  know
anything about the structure of the C++ code that is being wrapped and user
can trick it with things like  ~#.__karaxMarker__ = true~, but generally it
is not needed. Overwhelming majority of the patterns

# rg -g "*.nim" --no-filename --no-line-number --only-matching 'importcpp:\s*".*?"' |
#     sd 'importcpp:\s+"' '' | sd '"$' '' | sort | uniq  > importcpp

*** Problem

- TODO compiler has no understanding  of the FFI structure, code templating
  has hacks,  99% of the  times it  is used for  trivial cases that  can be
  covered  by an  interface  file,  everything else  is  either covered  by
  ~{.emit.}~  or should  just  be  separated in  different  pieces of  code
  altogether.

*** Current state of the ecosystem

Simple  analysis of  different  ~importcpp~ patterns  shows  that they  are
*overwhelmingly* used  to account  for a number  of simple  patterns listed
here:

#+begin_src js
/^#?(->|\.|\.~|new\s)?[a-zA-Z0-9_:]+(\((@|#)?\))?$/d
/^\(?#\s*(\|\||&&|>=|<=|<<=|>>=|==|<<|>>|<|>|[-+*%&/~]=|=[-+*%&/~])\s*#\)?$/d
/^\(?#\s*[+*/%&-|^]\s*\)?#/d
/^([a-zA-Z_:]+\.?)+$/d
/^\(?(\+\+|\-\-|[-~*&!]|new)\s*(#|@)\)?$/d
/^#\(@\)$/d
/^#\[(#|@)\]$/d
/^\(#\)$/d
/^delete @$/d
/^#.[a-zA-Z_:]\*=\*#$/d
#+end_src

The patterns are:

- Wrap class method, ~new~ constructor or destructor.
  - NOTE: it should not be necessary  to wrap ~new~ directly as constructor
    wrappers can be generated automatically.
  - NOTE: sometimes  ~->~ or ~.~ is  used for wrapping, which  also removes
    flexibility.  Wrapper provides  /code  pattern to  use  when method  is
    invoked on pointer to object/, it does not exactly provide /information
    about the method's existence/
- Various operator calls: binary, unary
- ~scoped::class.method()~  call   or  similar  construct   with  qualified
  identifiers joined via dot.
  - EX: ~desktopChanged.connect~
- Call operator ~()~
- Index operator ~[]~
- Explicit delete wrap
- Assign to index

Cloning all packages in the list  using code listing below and then running
simple ~rg  | wc -l~  shows that number  of ~importcpp~ patterns  listed is
14503 (12490 unique).

#+caption: Clone all nimble packages
#+begin_src
set E:GIT_TERMINAL_PROMPT = 0
for url [(cat packages.json | jq '.[].url' --raw-output)] {
    try {
        git clone $url".git"
    } catch {

    }
}
#+end_src

#+caption: Count importcpp uses
#+begin_src
rg -g "*.nim" --no-filename ^
    --no-line-number --only-matching 'importcpp:\s*".*?"' |
    sd 'importcpp:\s*"' '' | sd '"$' '' | wc -l
#+end_src

Removing common patterns we get 274  (223 unique), which is ~0.018%~ of the
total number. And  large number of these patterns is  not exactly "special"
either:

#+caption: Filter out common patterns
#+begin_src
rg -g "*.nim" --no-filename --no-line-number --only-matching 'importcpp:\s*".*?"' |
    sd 'importcpp:\s*"' '' | sd '"$' '' | sed -r -f importcpp_remove.sed
#+end_src

#+caption: Some of the more trivial examples that weren't matched by sed
#+begin_example cpp
std::basic_string<'*0>(@)
std::pair <'0,'1>
std::make_shared<'*0>(#)
std::vector<'*0>(@)
at::detail::getCUDAHooks().compiledWithCuDNN()
#+end_example

There are, however, some very questionable constructs such as

#+caption: Unusual code
#+begin_example cpp
std::shared_ptr<'*0>(@, []('*0* ptr) { callCppPtrDestructor(ptr); nimPointerDeleter(ptr); })
std::unique_ptr<'*0, std::function<void('*0*)>>(@, []('*0* ptr) { callCppPtrDestructor(ptr); nimPointerDeleter(ptr); })
_InterlockedExchange(reinterpret_cast<LONG volatile *>(#), static_cast<LONG>(#))
fetch(#, #).then(r => r.json())
(window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB)
#+end_example


# Funnily  enough,  the  only  ~grep   -F  "#.operator"~  found  in  code  is
# ~#.operator=()~.

*** Solution

Instead  of relying  on fragile  and repetitive  ~importcpp~ patterns  that
completely loose  the structure  of the  library to be  wrapped we  need to
introduce  an  /interface  file/  concept.  Interface  file  would  contain
description of  the library  API in  a declarative  manner. The  concept of
/declarative/ wrapping description had actually been considered seven years
ago in [[https://github.com/xomachine/wraptool-cpp2nim][GitHub - xomachine/wraptool-cpp2nim: Macros allowing generating
compact and readable wrappers to C++ classes for Nim programming language]]
but sadly didn't gain that much traction.

Main purpose  of the interface  file is  to /present information  about the
library in  a structured way/.  Interface file can  either be a  product of
automatic  wrapper  generator  or  a result  of  manual  effort.  Interface
description is less laborious compared to the manual ~importcpp~ annotation
as it  reduces the  need for repeated  namespace and  ~header~ annotations,
makes patterns themselves simpler as well.

In addition  to several  minor quality-of-life improvements  interface file
could also  be used as a  source of information for  further automatization
such  as   ~newClass()~  and  ~initClass()~  method   generation,  GC-aware
constructor  calling  (using  placement   new)  and  even  customized  code
generation. All of this will be possible if writings are made structured.

# https://matrix.to/#/!MAXxvfCYnfYgZqSizw:matrix.org/$xQc8dhoTg3rHL4xbF6OlHKVyQegSwHm9cRRUfO0ZX4k?via=libera.chat&via=matrix.org&via=matrix.shaggypeak.com

*** TODO Interfacing with complicated C++ code

*** TODO Automatic binding generation
    :PROPERTIES:
    :ID:       71e3dd81-5fd0-43b4-871f-9dbad57571e4
    :END:

*** TODO Definition of done :project##dod:

** Code formatting solution :project##target:
   :PROPERTIES:
   :ID:       06f149af-0064-4176-aef6-1668e276afa4
   :END:

Official stance on  the improvement of the code  formatting solutions seems
to be somewhere in the neighborhood of "just format the code manually".

#+caption: IRC [[https://irclogs.nim-lang.org/17-07-2019.html#10:27:47][logs]]
#+begin_quote
teach a system without eyes how to make code visually appealing, how hard can it be?
#+end_quote

The  fact that  most  major  languages seem  to  have  solved the  problem,
sometimes even multiple times suggest that it is not so "hard" to implement
after  all. The  main issues  seems  to be  rooted  in the  lack of  proper
intermediate representation in the compiler.

*** Problem

~nimpretty~ itself is a fairly simple  tool. Implementation leaves a lot to
be  desired -  currently it  is  hacked into  ~parser.nim~ and  ~lexer.nim~
directly, with  multiple (total  of ~37  and ~23  respectively) conditional
compilation checks like

#+begin_src nim
  if p.tok.tokType in {tkCurlyDotRi, tkCurlyRi}:
    when defined(nimpretty):
      if p.tok.tokType == tkCurlyRi: curlyRiWasPragma(p.em)
    getTok(p)
#+end_src

This makes it really  hard to provide a global code  layout, leading to bad
formatting -- if the tool does  not even understand the code properly there
is no hope it would be able to format it in any reasonable manner.

*** Solution

Code formatting  should first get a  concrete syntax tree --  one that does
not loose positional and structural information  -- and then format it back
into the source code. We already  [[https://github.com/nim-works/nimskull/pull/361][implemented]] the code layout algorithm and
continuing the work in this direction.

*** TODO Definition of done
** Improving testing workflow

The  "language" project  consists  of several  parts  that are  effectively
layered on top of each  other -- core language primitives, metaprogramming,
external  libraries  and  so  on.  Test  suite  must  also  follow  layered
structure.

*** Language specification

TODO Core part of language specification

*** Additional feature tests

TODO Extra tests that provide required secondary safety net

*** Ensuring the code written in the language works

From the end  user perspective the ultimate objective of  the compiler test
suite  is to  ensure the  language will  not suddenly  break at  unexpected
places. In  order to support this  need core maintainers should  adopt some
kind of strategy.

Different  programming languages  have different  levels of  strictness and
guarantees when it  comes to backward compatibility and  ranging degrees of
attention  to  keeping  existing   code  working.  Some  languages  provide
specification that explicitly codifies what  the language *is*. Others have
a (reference)  implementation with accompanying test  suite which specifies
its  behavior in  different circumstances.  In that  case stability  of the
language largely depends on the test suite.

Mainline  uses a  combination of  language specification  and a  test suite
augmented by so called "important packages"  -- a list of external packages
whose tests are executed as a part  of CI run. This approach allows to keep
the "important"  part of the  ecosystem working  while making it  easier to
neglect writing tests  because it is easy to assume  that implementation is
/sufficiently tested/.

We want  to avoid  this inverse  dependency and instead  focus on  the core
tests as much as possible. The workflow for handling incoming issues should
be:

1. Someone discovers  a new implementation issue or  regression and reports
   it.
2. Test author should first consider if the problem signifies a hole in the
   specification.

   For example, if the issue is "FEATURE1 combined with FEATURE2 break when
   GC  is  used  on  BACKEND"  then  corresponding  specification  test  is:

   - "FEATURE1" works, "FEATURE2"  works, on all targets  and all backends,
     *or*
   - "FEATURE1 and FEATURE2"  can be combined in such and  such way. On all
     backends, for all garbage collectors

   As mentioned previous section ("Language specification") there can be no
   single way of writing tests so author should use common sense.

3. If it is  not possible to write a specification test  then a regular one
   is  created.  Problematic  snippet  should   be  reduced  and  added  to
   appropriate subdirectory in the test suite.

As you can see specification itself  should be enough -- all relevant parts
of the language can  be specified in an orthogonal way  and then there will
be no need for  an extra safety net. In theory.  In reality secondary level
of   tests  makes   it  possible   to  account   of  deficiencies   in  the
implementation: no matter  how orthogonal the language design  is there are
bound to be bugs, architectural issues  and so on. Additional feature tests
are designed to account for this.

"important packages" could've provided a tertiary layer of safety, but they
create  an  inverse  dependency  that  incur  unjustifiable  slowdowns  and
questionable [[https://github.com/nim-lang/Nim/commits/devel/testament/important_packages.nim][fiddling]] with the package list:

- [[https://github.com/nim-lang/Nim/pull/18292][disable pkg manu by timotheecour · Pull Request #18292 · nim-lang/Nim ·
  GitHub]]
- [[https://github.com/planetis-m/manu/issues/5][manu breaks important_packages · Issue #5 · planetis-m/manu · GitHub]]
- [[https://github.com/fowlmouth/nake/issues/77][nake breaks manu which breaks important_packages · Issue #77 ·
  fowlmouth/nake · GitHub]]
- [[https://github.com/nim-lang/Nim/commit/83128f217f63045974a48e61b65386abbfc97352][disable testing of `fidget`, to make CIs green · nim-lang/Nim@83128f2 ·
  GitHub]]
- [[https://github.com/nim-lang/Nim/pull/18601][fixes #18543 by Araq · Pull  Request #18601 · nim-lang/Nim · GitHub]] (note
  [[https://github.com/nim-lang/Nim/pull/18601#issuecomment-889381407][ignored]] commit message improvement suggestion)

* Part six: my vision

#+begin_center
Why *I* decided to contribute to this specific project.
#+end_center

I've already provided  most of the historical context I  could get my hands
on, so in this  part I'm instead going to focus on  the my personal account
of working for nimskull.

* Part seven: my scopes
  :PROPERTIES:
  :ID:       df3bccc6-1850-4ad1-85ff-44776c59f15c
  :END:

As a  contributor to the project  I have some  ideas of my own  that either
haven't been  in the discussion  for a long time  or too fuzzy  to properly
place on the roadmap. I will  discuss them in the following section, adding
to the master plan from the part five.

In  most cases  they  have  already been  discussed  /somewhat/ in  various
places, but are currently too far from the present state of things.

** Automatic migration and refactoring tool

Automatic migration tool with code  rewriting patterns would make it easier
to implement language changes.

- NOTE related to [[id:06f149af-0064-4176-aef6-1668e276afa4][Code formatting solution]] --  you need to be able to parse
  code in, edit the tree and render it back reliably.
- TODO find with  other languages implement similar solutions:  I think elm
  (or some web/haskell-like thing) had this.
- TODO  Different types  of automatic  code rewriting  -- based  on untyped
  tree, on typed tree.
- TODO  clang  AST  tooling  solutions  --  document,  detail.  Large-scale
  refactoring problems.

** Standard library and ~system.nim~ :project##target:
   :PROPERTIES:
   :ID:       274807cd-8a54-46c4-97ec-babc2959eec8
   :END:

# https://discord.com/channels/371759389889003530/371759389889003532/903972578773839892

# https://matrix.to/#/!alsWvZtOfWkQlHwcHC:envs.net/$_Kp6CVZzg7CEFIG55dWU11I5vyi9dAphJj89dzYnypo?via=libera.chat&via=matrix.org&via=matrix.shaggypeak.com

# https://github.com/nim-lang/Nim/pull/18711#discussion_r695650857

#+begin_quote
if we take as a given that a working package manager is a requirement, then the stdlib really only needs to serve the compiler and any bundled tools.
#+end_quote

"Batteries included" can  be achieved by creating a  default release bundle
which includes "common" things.

- TODO What is "batteries included" anyway?
- NOTE some  of the complaints  about dependency on package  manager worked
  off the assumption  it would be all-encompassing tool that  you can't get
  around, ~nim.cfg~ is a pretty questionable solution.
- TODO status rewrote half of the stdlib for themselves anyway

** Documentation generation :project##target:

*** Problem

Specific features of the documentation generator have always been a notable
pain point for me  with respect to the ~nim doc~  command. Some people have
already ([[https://gradha.github.io/articles/2015/08/sad-ways-documentation-generation-tools-suck.html][Sad ways documentation generation tools suck - Rants from the
Ballmer Peak]]) voiced ([[https://github.com/nim-lang/RFCs/issues/447][Split documentation generation for easier tooling
and better jsondoc · Issue #447]]) their ideas and concerns. Missing pieces
include

- Ability to sort generated documentation in any way -- entries are grouped
  based on the macro/iterator/proc/func/template/method/type basis and then
  sorted alphabetically.
- Incredibly  verbose  system of  the  internal  references that  makes  it
  largely unusable for any sort of complex linking.

  In order to link the type somewhere you  need to spell out a full name of
  the  procedure with  all of  its argument  types. Now  imagine trying  to
  casually write documentation for some internal compiler module and having
  to link /this/:

  #+caption: pickBestCandidate is a semcall.nim function
  #+begin_src nim
proc pickBestCandidate(c: PContext,
                       headSymbol: PNode,
                       n: PNode,
                       initialBinding: PNode,
                       filter: TSymKinds,
                       best, alt: var TCandidate,
                       errors: var seq[SemCallMismatch],
                       flags: TExprFlags) =
  #+end_src

  Note -- the whole  codebase has a single procedure with  this name, so it
  is entirely possible to just resolve it from the name alone.

  TODO link PMunch's PR for json export, link article from gradha again

- It  is not  possible  to  get structured  output  from the  documentation
  generator. Produced 'structured' json  internally contains formatted HTML
  pieces instead of a structured information.

- Documentation generation happens in a single run, with ~runnableExamples~
  handled in a non-parallel way. Syntactic  errors in a single comment fail
  the whole  project build and so  do runnable examples. Running  either of
  the  source  code  pieces   below  with  src_sh{nim  doc  --errormax=1290
  file.nim} will  cause compilation  to fail  on a  first invalid  piece of
  code.

  #+caption: Syntax error in the documentation
  #+begin_src nim
proc bad*() =
  ## *??

proc thing*() =
  ## *?
  #+end_src
- Implementation of the documentation generator is pre
- TODO runnable examples are not parallelized
- TODO ~define()~-hidden conditionals are not documented
- Just as  most of the other  core tools documentation generator  lacks any
  form of intermediate  representation that can be used to  easily create a
  structured  output.  Things are  often  [[https://github.com/nim-lang/Nim/blob/daf35c6d1b4bc1377bf278aa265dab30c9f5867e/compiler/docgen.nim#L1204][formatted]]  in-place or  converted
  [[https://github.com/nim-lang/Nim/blob/daf35c6d1b4bc1377bf278aa265dab30c9f5867e/compiler/docgen.nim#L1117][directly]] from ~PNode~ [[https://github.com/nim-lang/Nim/blob/daf35c6d1b4bc1377bf278aa265dab30c9f5867e/compiler/docgen.nim#L1108][to]] json, HTML or LaTeX with [[https://github.com/nim-lang/Nim/blob/daf35c6d1b4bc1377bf278aa265dab30c9f5867e/compiler/docgen.nim#L379][two]] [[https://github.com/nim-lang/Nim/blob/daf35c6d1b4bc1377bf278aa265dab30c9f5867e/compiler/docgen.nim#L477][hardcoded]] [[https://github.com/nim-lang/Nim/blob/daf35c6d1b4bc1377bf278aa265dab30c9f5867e/compiler/docgen.nim#L515][outputs]].

  Lack of  IR is  an obvious  issue that  prevents any  sort of  the output
  customization.  A better  solution  would be  to  have some  intermediate
  machine-readable format that can then  be converted into a human-readable
  output.  Because documentation  generator effectively  needs to  create a
  database  of the  whole project  the most  obvious solution  would be  to
  create an sqlite database from the code.

*** Solution

Instead of merging  code analysis and HTML/Latex generation  steps into one
tool it is  much better to split into two  stages: analysis with subsequent
database generation and output formatting.

**** Specific details of the documentation database

The database should be generated in the  SQLite format as it is the easiest
form of  data serialization if DOD  structures are used. The  whole project
can be  represented using two main  tables (and a handful  of supplementary
ones):

- entries :: central table of the database, holds /Documentable Entries/ --
  any piece of code that  can have attached documentation. Objects, macros,
  procedures /and  their arguments/,  files, /directories/,  /packages/ and
  much more.

  Each documentable entry stores ID of it's parent, documentation, range in
  the source code and any  other additional information if applicable (such
  as deprecation status and message, "since" semantic annotation).

  In conventional  documentation generators this table  (and it's auxiliary
  elements) would  be the  only one.  End user is  able to  read explicitly
  available documentation formatted to their preference.

- references :: List of inter-entry references. Which procedure calls which
  function, what exceptions are raised, what objects are constructed, where
  the variable is read.

  This table  provides information that  is very important  for documenting
  the inner  workings of the projects.  This is the part  that conventional
  documentation generators don't address --  aside from tools such as woboq
  and sourcetrail.

  One of the most important long-term objectives of the nimskull project is
  to make compiler code base approachable to the newcomers and this sort of
  information would  make it  much easier  for them to  get the  answers to
  questions such  as /"what are  the possible  paths between this  point in
  code and  this point[fn:point-1545]"/,  /"Where this function  is used"/,
  /"Starting from  this point, is it  possible something is written  to the
  global variable?"/ and many others.

[fn:point-1545] Can  be visualized using  call information --  two function
"reference" each other when the call is in the code.

**** TODO How it will solve some issues right away

- runnable  examples  can   be  stored  in  the  database  as   a  part  of
  documentation   and  executed   in  parallel   later,  no   more  layered
  interruptions in the documentation generation pipeline.

**** TODO Documentation markup format

Mainline uses =ReStructured= text with  large number of markdown extensions
that  were requested  by people  over the  years such  as links,  headings,
tables, code blocks. Aside from rather cumbersome syntax RST is well-suited
for writing documentation: it  provides customizable interpreted text notes
(~:cmd:~), admonitions.

Most  of  the  programming  languages are  currently  using  markdown  with
different   flavors  and   customized  extensions:   Rust,  C++   (Doxygen,
clang-doc), Java, Zig  and so on. In each case  developers add non-standard
syntactical extensions for things such as:

- admonitions: TODO link Doxygen, rust-doc
- description lists:
- file includes
- a syntax to link other entries in the documentation


**** TODO Interesting new features
     :LOGBOOK:
     - State "TODO"       from              [2022-11-18 Fri 12:21:10]
     :END:

*** Extra features that solution would enable

- Because public API can now be  stored in a fixed-format database it might
  be  possible to  determine the  differences between  two versions  of the
  public API.

** Package management solution
   :PROPERTIES:
   :ID:       718bfd67-5f93-4b54-89f4-32ff864b79fb
   :END:

*** Problem

Putting aside many different implementation, UX and ideological issues with
nimble that I already outlined in  the previous section, the most important
one is the philosophy it tries to impose on the user. Fundamentally it says
that there should be only one command  nim user should use and it should be
~nimble~. Install packages,  compile the code, run the code,  test the code
and so on. There is a lot of  information that you can't get out of nimble,
even in the ~.nimble~ script.

- If you  have a  custom ~test~  target and want  to get  the full  list of
  packages in the same way as a native ~test~ does -- it is not possible.
- If you want to run an extra  tool, such as ~testament~ for your tests and
  pass the list of the packages nimble  knows about -- you can't, this data
  is not exposed.

*** Package manager assumptions solution

Key  ideas of  the package  management  solution is  that *package  manager
manages the environment* and *if the environment hasn't changed the package
manager does not need to run*.

There  is already  a notion  of the  "environment" via  ~nim.cfg~ that  can
specify  the   ~--path="<package  path>"~  configuration  options   to  the
compiler or any other tool that can be put in the compilation pipeline.

- A package  manager to  manage your  package installation.  Downloads your
  packages  and   resolves  things   using  information  provided   by  git
  submodules.  When version  conflict occurs,  we use  the MVS  strategy to
  resolve which version of the library you  end up getting in the end. When
  the package  manager finishes  execution, you are  left with  a ~nim.cfg~
  file  that   contains  ~--path:~  parameters  with   specify  where  each
  dependency was installed in the end.
- ~<build  tool>~ that  might  be  used after  package  download stage  has
  finished. At  this point  it is  used to finish  the installation  of the
  packages  -  for some  libraries  it  might  be  needed to  perform  some
  additional actions, like building ~.so~.
- After  all  of your  packages  are  correctly  (1) *downloaded*  and  (2)
  *installed*, you can start compiling your code using nim compiler.

*** Dependency resolution algorithm solution

There  are many  counterpoints  to the  minimum  version selection  package
managers, most of  which talk about how things are  "usually" done and that
it "does not  make sense" or "nobody would manually  upgrade the packages".
Most of them effectively  boil down to the fact that =MVS=  is not the best
tool for every single workflow, which is perfectly understandable.

There  are  also   several  considerations,  both  of   the  technical  and
ideological  nature  that  are  involved  in  decision  about  how  package
management is done.

- First  and foremost  -- /proper/  implementation of  the maximum  version
  selection  is  a  complicated  task  because  the  problem  itself  is  a
  NP-complete. There have  been [[https://github.com/nim-lang/nimble/issues/890][discussions]] about using  a better algorithm
  for the resolution,  but it is still pretty  sophisticated, [[https://nex3.medium.com/pubgrub-2fb6470504f][especially]] if
  you want to get a [[ for the resolution failures][good]] UX.

  Minimum  version selection,  on the  other hand,  is a  trivial and  very
  predictable algorithm that  can be written in a hundred  lines of code or
  so.
- Second -- usage  of the =MVS= would require package  authors to be honest
  with what  their requirements are. If  you actually need the  ~0.4.0~ and
  not the ~0.3.0~ you should no longer rely on the implicit assumption that
  PM will "do the right thing".
- Thirdly -- package manager won't suddenly pull a different version of the
  dependency unless you explicitly specify it can do so.
- Extra  -- it  is possible  to transform  ecosystem that  was bout  around
  minimum version selection into one  that favors maximum version selection
  because it will  effectively require relaxing the  version ranges. Making
  transition the other way might be too hard.
- Extra -- =MVS=  requirements are less vulnerable to bitrot.  If you write
  the package that uses specific versions, leave it for five years and come
  back, it will pull the same versions.

Based on above points it is safe  to assume that =MVS= is a better solution
at the start.

Package resolution algorithm is pretty  simple:

- Package directory path and git URL  of the package to install is supplied
  to the package manager.
- First package is cloned to the directory path. If specific version of the
  package is required it is [[https://git-scm.com/docs/git-checkout][checked out]].
- Each    package   contains    specification    of   requirement    ranges
  ~requirements.toml~ (name/format are provisional) which is looked over to
  determine which packages to download next.
- For each newfound package:
  - If new package is required and  is missing it is downloaded and checked
    out to a minimum possible version.
  - If  new package  is  required and  had already  been  downloaded it  is
    checked to a new minimum  version, which is computed as ~max(min_first,
    min_second)~
- New  packages  are processed  recursively  and  cloned into  the  package
  directory as needed.
- After  installation   process  is  finished  package   manager  generates
  ~nim.cfg~ file  which contains  multiple ~--path=~,  pointing to  the new
  package locations.

After installation  any tool can  read ~nim.cfg~ and get  information about
packages.


---------------------

- List of requirements can potentially be replaced to git submodules, but a
  lot of people find them confusing, they are not as approachable as simple
  ~config.toml~ file.
- Dependency  resolution  algorithm  transparently treats  both  local  and
  remote packages.  If you need  to develop a  package locally you  can use
  symbolic link and it will be  processed as "required and had already been
  downloaded".
- You can roll any particular dependency to a specified version as needed -
  either independently or updating versions  for all packages. This is very
  handy for upgrading dependencies.
- Lock files can be trivially  implemented by writing dependency hash trees
  into a separate file.

# TODO  if  I fork  one  of  my dependencies  (F)  and  another one  of  my
# dependencies (D1)  also depends on  the forked  project, how can  this be
# represented in  requirements file? This use  case "just works" if  I have
# everything locally -  "fork" simply replaces whatever I  had for package,
# but  the environment  is not  impossible  to reproduce.  NOTE this  might
# require support for  more than one package linked into  the main project.
# TODO ping @saem about this one.

*** "Single tool" solution

In several cases the importance of a single tool, which can perform all the
project-related activity, has been emphasized. Go has often been used as an
example.  Solution above  is completely  orthogonal to  this request  as it
would be trivial  to provide a main  driver program, in the  same manner as
~clang++~ is a driver on top of multiple smaller execution actions.

Keeping things separate on the implementation level still allows to provide
a unified  interface that would even  support a user-provided actions  in a
manner similar to the ~git~ subcommands.
