<введение>

# * Кратное введение в работу компилятора

# Макросы по своей сути сильно связаны с процессом работы компилятора, так
# что для простоты понимания принципов их работы желательно иметь как минимум
# поверхностное представление о том что у компилятора "внутри", хотя это и не
# является строго обязательным.

Относительно терминологии - для избежания путаницы с тем что такое
"оператор", "команда", "инструкция" и "выражение" - так как однозначно
устоявшегося перевода нет то я счел необходимым привести уточнение
(например в википедии сказано что "Инструкция или оператор (англ.
statement) — наименьшая автономная часть языка программирования; команда
..."), а в нижеприведенном тексте это все может использоваться одновременно
и иметь значения которые не являются взаимозаменяемыми.

- оператор "operator" :: инфиксный или префиксный - ~a + b~, ~not e~, ~12 mod 18~
- команда "command" :: один из вариантов синтаксиса вызова процедуры - ~echo "test"~
- инструкция "statement" :: тип синтаксиса языка, ~for~, ~while~
- выражение "expression" :: еще один тип синтаксиса

И оператор и команда могут быть как выражением так и инструкцией в
зависимости от контекста. Например

#+begin_src nim :exports both
proc `not`(arg: string) = discard

not "test" # префиксный оператор `not` используется как инструкция
echo (not false) # Префиксный оператор используется как выражения-аргумент
                 # для процедуры `echo`, которая в свою очередь уже
                 # является инструкцией.
#+end_src

#+RESULTS:
: true

* Макросы, использование

Основное предназначение макросов - создание DSL или автоматизация рутинного
кода.

** Аргументы макроса

Аргументы макроса могут иметь один из трех видов - ~typed~, ~untyped~ и
~static[T]~ где ~T~ это какой-то тип, например ~int~ или ~string~.

*** ~untyped~

Если аргумент имеет тип ~untyped~ то макрос вызывается *до* семантической
проверки кода и принимает на вход синтаксическое дерево как оно написано в
коде.

На данный момент нетипизированное синтаксическое дерево является частью
стабильного API. С тем как оно выглядит для основных конструкций языка
можно ознакомится в [[https://nim-lang.org/docs/macros.html][документации]].

#+begin_src nim :exports both
macro withUntyped(arg: untyped) = echo lispRepr(arg)

withUntyped(12 + 2)
withUntyped(echo(12, 32))
#+end_src

#+RESULTS:
: (Infix (Ident "+") (IntLit 12) (IntLit 2))
: (Call (Ident "echo") (IntLit 12) (IntLit 32))

Если нужно посмотреть как выглядит какой-то определенный кусок кода то
можно воспользоваться макросами [[https://nim-lang.org/docs/macros.html#dumpTree.m%2Cuntyped][dumpTree]] или [[https://nim-lang.org/docs/macros.html#dumpLisp.m%2Cuntyped][dumpLisp]].

#+begin_src nim :exports both
dumpTree:
  for i in 0 .. 12:
    echo i
#+end_src

#+RESULTS:
#+begin_example
StmtList
  ForStmt
    Ident "i"
    Infix
      Ident ".."
      IntLit 0
      IntLit 12
    StmtList
      Command
        Ident "echo"
        Ident "i"
#+end_example

*** ~typed~

В случае аргументов типа ~typed~ макрос вызывается *после* семантической
проверки и принимает преобразованное синтаксическое дерево.

На данный момент структура типизированного синтаксического дерева не
является частью стабильного API, технически это деталь реализации
компилятора. Это не означает что это что-то открыто
нестабильное/экспериментальное - просто никаких четких гарантий по
структуре нет.

#+begin_src nim :exports both
macro withTyped(arg: typed) = echo lispRepr(arg)

withTyped(12 + 2)
withTyped(echo(12, 32))
#+end_src

#+RESULTS:
: (IntLit 14)
: (Call (Sym "echo") (HiddenStdConv (Empty) (Bracket (StrLit "12") (StrLit "32"))))

В этом примере уже можно видеть что были произведены дополнительные
преобразования в коде - ~12 + 2~ было превращено в ~12~ за счет [[https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%91%D1%80%D1%82%D0%BA%D0%B0_%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82][свертки
констант]]. Аналогичное преобразование было произведено для аргументов
~echo~, но в данном случае для оператора ~$~. Также был добавлены
квадратные скобки (~Bracket~) для всех аргументов, так как ~echo~ это
процедура с ~varargs~ аргументами.

В случае в ~untyped~ также можно писать какой-то конкретный тип, для того
чтобы создавать перегруженные макросы.

#+begin_src nim :exports both
macro overloaded(arg: int) = echo "called int: ", lispRepr(arg)
macro overloaded(arg: string) = echo "called string: ", lispRepr(arg)

overloaded(12)
overloaded("string")
#+end_src

#+RESULTS:
: called int: (IntLit 12)
: called string: (StrLit "string")

*** ~static[T]~

** Порядок раскрытия макросов и выполнения кода на этапе компиляции.

Во время обработки программы компилятор анализирует исходный код в порядке
его написания, начиная с самой первой инструкции, пошагово. Последнее
значит, что прежде чем приступить к обработке следующей инструкции первого
уровня компилятор полностью должен закончить работу с предыдущей. Это нужно
для того чтобы макросы могли генерировать процедуры, которые используются в
дальнейшем коде (в том числе и других макросах).

Каждая инструкция рекурсивно раскрывается (и в случае ~static:~
выполняется) пока в полученном дереве не будет ни одного вызова макроса.

** Использование в коде

Макросы могут быть использованы в нескольких вариантах, включая обычные
вызовы (~call(arg)~ или ~call arg~).

Макрос также можно использовать в качестве [[https://nim-lang.org/docs/manual.html#pragmas][прагмы]] на определениях типов,
функций и процедур.

# Мне казалось что каким-то магическим образом можно также использовать на
# определении переменных, но так как `let variable {.userPragma.} = 12`
# выдает ошибку неопределенном идентификаторе ~variable~ с тех пор что-то
# изменилось.

Макрос, использующийся на определении процедуры имеет один аргумент, и
может ничего не возвращать - также как и любой другой макрос который
используется для инструкций.

#+begin_src nim :exports both
macro userPragma(arg: untyped): untyped =
  echo treeRepr(arg)

proc definition(arg: int): float {.userPragma.} = discard
#+end_src

#+RESULTS:
#+begin_example
ProcDef
  Ident "definition"
  Empty
  Empty
  FormalParams
    Ident "float"
    IdentDefs
      Ident "arg"
      Ident "int"
      Empty
  Empty
  Empty
  StmtList
    DiscardStmt
      Empty
#+end_example




* Нетипизированные макросы

* Типизированные макросы

Основное отличие типизированных макросов от нетипизированных заключается в
том, на каком этапе компиляции они выполняются. Типизированные макросы
выполняются после семантической проверки и принимают на вход AST в которое:

1. все вызовы макросов или шаблонов внутри уже раскрыты, ~f(g(x))~ -
   аргументом ~f~ будет являться /скомпилированный результат/ выполнения
   ~g(x)~, а не /вызов/ самой функции, как это было в случае с
   нетипизированными макросами.

   Т.е. в случае с ~f(g(x))~ сначала будет выполнен ~g(x)~, после чего
   результат его работы будет скомпилирован, и передан как аргумент ~f~
2. содержит ~nnkSym~ элементы вместо ~nnkIdent~
3. может содержать дополнительные элементы, такие как ~nnkOpenSymChoice~,
   ~nnkClosedSymChoice~, и т.д.
4. может содержать свернутые константные выражения - например ~$(12 + 12)~
   может быть переведено в ~"24"~.

** Для чего нужны типизированные макросы

Есть несколько различных причин по которым вам может потребоваться
использование типизированного макроса - самой частой является доступ к
дополнительной информации, которая просто недоступна для нетипизированного
случая. Второй причиной часто является тот факт что только типизированные
макросы обеспечивают корректную композицию, так как в связи с п.1,
структура дерева

** Структура типизированного синтаксического дерева

*** Ноды символов - ~nnkSym~, ~nnkOpenSymChoice~, ~nnkClosedSymChoice~

** Работа с типизированным синтаксическим деревом

*** Получение информации из символов

*** Трансформация типизированного дерева

*** Работа с типами
