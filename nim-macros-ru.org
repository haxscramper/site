<введение>

# * Кратное введение в работу компилятора

# Макросы по своей сути сильно связаны с процессом работы компилятора, так
# что для простоты понимания принципов их работы желательно иметь как минимум
# поверхностное представление о том что у компилятора "внутри", хотя это и не
# является строго обязательным.

* Макросы, использование

Основное предназначение макросов - создание DSL или автоматизация рутинного
кода.

** Использование в коде

Макросы могут быть использованы в нескольких вариантах, включая обычные
вызовы (~call(arg)~ или ~call arg~).

#+caption: Использование макроса как прагмы для функции
#+begin_src nim :exports both
import std/macros
macro userPragma(arg: untyped): untyped =
  echo treeRepr(arg)

proc definition(arg: int): float {.userPragma.} = discard
#+end_src

#+RESULTS:
#+begin_example
ProcDef
  Ident "definition"
  Empty
  Empty
  FormalParams
    Ident "float"
    IdentDefs
      Ident "arg"
      Ident "int"
      Empty
  Empty
  Empty
  StmtList
    DiscardStmt
      Empty
#+end_example


* Нетипизированные макросы

* Типизированные макросы

Основное отличие типизированных макросов от нетипизированных заключается в
том, на каком этапе компиляции они выполняются. Типизированные макросы
выполняются после семантической проверки и принимают на вход AST в которое:

1. все вызовы макросов или шаблонов внутри уже раскрыты, ~f(g(x))~ -
   аргументом ~f~ будет являться /скомпилированный результат/ выполнения
   ~g(x)~, а не /вызов/ самой функции, как это было в случае с
   нетипизированными макросами.

   Т.е. в случае с ~f(g(x))~ сначала будет выполнен ~g(x)~, после чего
   результат его работы будет скомпилирован, и передан как аргумент ~f~
2. содержит ~nnkSym~ элементы вместо ~nnkIdent~
3. может содержать дополнительные элементы, такие как ~nnkOpenSymChoice~,
   ~nnkClosedSymChoice~, и т.д.
4. может содержать свернутые константные выражения - например ~$(12 + 12)~
   может быть переведено в ~"24"~.

** Для чего нужны типизированные макросы

Есть несколько различных причин по которым вам может потребоваться
использование типизированного макроса - самой частой является доступ к
дополнительной информации, которая просто недоступна для нетипизированного
случая. Второй причиной часто является тот факт что только типизированные
макросы обеспечивают корректную композицию, так как в связи с п.1,
структура дерева

** Структура типизированного синтаксического дерева

*** Ноды символов - ~nnkSym~, ~nnkOpenSymChoice~, ~nnkClosedSymChoice~

** Работа с типизированным синтаксическим деревом

*** Получение информации из символов

*** Трансформация типизированного дерева

*** Работа с типами
